


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="">
    
    
      
        <title>May 2024 - fdaPDE  documentation</title>
      
    
    
      
      


    
    
      
    
    
      
        
        
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="../_static/sphinx_immaterial_theme.243c798c14787bf0e.min.css?v=a4497153" />
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../index.html" title="fdaPDE  documentation" class="md-header__button md-logo" aria-label="fdaPDE  documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            fdaPDE  documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              May 2024
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
                
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="fdaPDE  documentation" class="md-nav__button md-logo" aria-label="fdaPDE  documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>
    </a>
    fdaPDE  documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/tut_1.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Example 1:<wbr> A non-<wbr>linear diffusion reaction problem
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/tut_2.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Example 2:<wbr> The Heat equation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/tut_5.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Example 3:<wbr> SUPG for advection dominated equations
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/tut_4.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Example 4:<wbr> The Stokes problem
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/alpha_testing.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Alpha testing fda<wbr>PDE 2.<wbr>0 <wbr>[cpp]
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
                
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" hidden>
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary">
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset" role="main">
                
                
                  
  



<h1 id="may-2024">May 2024<a class="headerlink" href="#may-2024" title="Link to this heading">¶</a></h1>
<p>Reached 10K lines of code.</p>
<div class="success admonition">
<p class="admonition-title">RcppEigen version upgraded to 0.3.4</p>
<p><code class="code docutils literal notranslate"><span class="pre">RcppEigen</span></code> has been updated to Eigen v3.4.0 (version 0.3.4 of the <code class="code docutils literal notranslate"><span class="pre">RcppEigen</span></code> package released on CRAN on 2024-02-28). There are no more restrictions for using Eigen v3.3.9, therefore the whole C++ codebase will upgrade the Eigen version to the 3.4.0. Code will not compile anymore with Eigen v3.3.9 as it already makes use of <a class="reference external" href="https://eigen.tuxfamily.org/dox/group__TutorialSlicingIndexing.html">slicing, indexing</a>  and <a class="reference external" href="https://eigen.tuxfamily.org/dox/group__TutorialSTL.html">Eigen support for STL iterators</a> available only in the 3.4 version.</p>
<p>The fdaPDE-R package DESCRIPTION and the various CMakeLists.txt files have been updated. femR will need to update its DESCRIPTION file when aligned to the mainstream fdaPDE-core library.</p>
<p>As a consequence of this upgrade, there are no limitations for using the C++20 standard, as announced in February 2024.</p>
</div>
<div class="danger admonition">
<p class="admonition-title">Warnings are errors</p>
<p>From this update on, to achieve high-quality code, tests are compiled with the options <code class="code docutils literal notranslate"><span class="pre">-Wall</span> <span class="pre">-Wpedantic</span> <span class="pre">-Wextra</span> <span class="pre">-Werror</span></code>. This setting enables the majority of the interesting warnings, and considers warnings as errors (<code class="code docutils literal notranslate"><span class="pre">-Werror</span></code> flag). That said, warnings cannot be ignored anymore. This options should help also for a less painfull interface with the CRAN rules.</p>
</div>
<p><strong>core</strong></p>
<ul>
<li><p><strong>geometry</strong>: the geometry module is under a major rewriting, and is the first step toward a more general core library system. While work is still in progress, here a list of the already official features:</p>
<div class="abstract admonition">
<p class="admonition-title">Nomenclature</p>
<p>Inside the geometry module, we will refer with <em>cell</em> what in finite element analysis is usually named element, that is, depending on the dimensionality of the domain, a <em>cell</em> will be a segment (1D, 1.5D), a triangle (2D, 2.5D) or a tetrahedron (3D).</p>
<p>We will name <em>node</em> a vertex of a <em>cell</em>. For triangular meshes, the name <em>edge</em> refers to a boundary segment of a triangle. For tetrahedral meshes, the name <em>face</em> denotes a boundary triangle of a tetrahedron, while the name <em>edge</em> refer to a boundary segment of such triangle, i.e. is a 3D segment (to be cristal clear, a tetrahedron has 4 faces and 6 edges).</p>
</div>
<ul class="simple">
<li><p>template <code class="code docutils literal notranslate"><span class="pre">Element&lt;int</span> <span class="pre">LocalDim,</span> <span class="pre">int</span> <span class="pre">EmbedDim&gt;</span></code> has been removed. <code class="code docutils literal notranslate"><span class="pre">Element</span></code> was a generic way to indicate a single segment/triangle/tetrahedron inside a mesh. Its presence was a problem, as the resulting interface was a bit controversial (for instance, a triangle had to define both a concept of face and of edge, which in this case are equivalent). Moreover, it was impossible to work on a simple cell without having an entire mesh structure, which was a bit annoying.</p></li>
</ul>
<p>The following structure has been introduced:</p>
<ul>
<li><p><strong>Simplex</strong>: <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> represents a generic <a class="reference external" href="https://en.wikipedia.org/wiki/Simplex">simplex</a> embedded in an <code class="code docutils literal notranslate"><span class="pre">EmbedDim</span></code>-dimensional space. The template parameter <code class="code docutils literal notranslate"><span class="pre">Order</span></code> sets the order of the simplex, e.g. depdending on its value, <code class="code docutils literal notranslate"><span class="pre">Simplex</span></code> represents a segment (<code class="code docutils literal notranslate"><span class="pre">Order</span></code> = 1), a triangle (<code class="code docutils literal notranslate"><span class="pre">Order</span></code> = 2) or a tetrahedron (<code class="code docutils literal notranslate"><span class="pre">Order</span></code> = 3). Higher orders are available, but from a geometrical viewpoint there is no interest in having <code class="code docutils literal notranslate"><span class="pre">Order</span> <span class="pre">&gt;</span> <span class="pre">3</span></code>. The following geometric operations are available on a simplex:</p>
<table class="docutils data align-default" id="id1">
<caption><span class="caption-text"><strong>Simplex API</strong></span><a class="headerlink" href="#id1" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 40.0%" />
<col style="width: 60.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">measure()</span></code></p></td>
<td><p>measure of the simplex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">bounding_box()</span></code></p></td>
<td><p>returns the smallest rectangle containing the simplex.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">barycenter()</span></code></p></td>
<td><p>returns the midpoint (center of mass) of the simplex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">barycentric_coords(const</span> <span class="pre">NodeType&amp;</span> <span class="pre">p)</span></code></p></td>
<td><p>given a point <span class="math notranslate nohighlight">\(p\)</span>, rewrites it in the barycentric coordinate system of the simplex.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">circumcenter()</span></code></p></td>
<td><p>returns the center of the (hyper)-sphere passing through the vertices of the simplex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">circumradius()</span></code></p></td>
<td><p>returns the radius of the (hyper)-sphere passing through the vertices of the simplex.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">contains(const</span> <span class="pre">NodeType&amp;</span> <span class="pre">p)</span></code></p></td>
<td><p>given a point <span class="math notranslate nohighlight">\(p\)</span> determines if the point is inside, on a boundary cell, on a vertex or outside of the simplex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">supporting_plane()</span></code></p></td>
<td><p>the <code class="code docutils literal notranslate"><span class="pre">HyperPlane&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> passing through the simplex.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">normal()</span></code></p></td>
<td><p>the normal direction to the simplex (meaningfull only if <code class="code docutils literal notranslate"><span class="pre">Order</span> <span class="pre">!=</span> <span class="pre">EmbedDim</span></code>, otherwise returns zero).</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">nearest(const</span> <span class="pre">NodeType&amp;</span> <span class="pre">p)</span></code></p></td>
<td><p>given a free point <span class="math notranslate nohighlight">\(p\)</span>, finds the best approximation of <span class="math notranslate nohighlight">\(p\)</span> in the simplex (e.g., the point in the simplex which is nearest to <span class="math notranslate nohighlight">\(p\)</span>).</p></td>
</tr>
</tbody>
</table>
<p><code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> also provides a <code class="code docutils literal notranslate"><span class="pre">boundary_iterator</span></code> type which let iterate over the boundary cells of the simplex as <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">EmbedDim&gt;</span></code> simplices (which means that you have all the API above for each boundary cell).</p>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> data type is mainly for internal usage. It is in turn inherited by other high-level concepts. Check the <code class="code docutils literal notranslate"><span class="pre">Triangle</span></code>, <code class="code docutils literal notranslate"><span class="pre">Tetrahedron</span></code>, etc. types below. The point of <code class="code docutils literal notranslate"><span class="pre">Simplex</span></code> is to be a free geometric object, i.e. without any connectivity information related to the presence of an underlying triangulation. Neverthless, having the ability to work on a free geometric object turns out to be usefull in many applications.</p>
</div>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>Simplex API<a class="headerlink" href="#id2" title="Permalink to this code">¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="c1">// create a 2D triangle (Simplex of order 2, embedded in a 2D space)</span>
<span class="n">SMatrix</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vertices</span><span class="p">;</span>
<span class="n">vertices</span><span class="w"> </span><span class="o">&lt;&lt;</span>
<span class="w">   </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.8</span><span class="p">;</span>
<span class="n">Simplex</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">triangle</span><span class="p">(</span><span class="n">vertices</span><span class="p">);</span>

<span class="n">triangle</span><span class="p">.</span><span class="n">measure</span><span class="p">();</span>
<span class="n">triangle</span><span class="p">.</span><span class="n">circumcenter</span><span class="p">();</span>
<span class="c1">// ... see the table above ...</span>

<span class="c1">// compute the perimeter of the triangle using STL algorithms :)</span>
<span class="kt">double</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span>
<span class="w">   </span><span class="n">triangle</span><span class="p">.</span><span class="n">boundary_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">triangle</span><span class="p">.</span><span class="n">boundary_end</span><span class="p">(),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">perimeter</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">perimeter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">measure</span><span class="p">();</span>
<span class="w">   </span><span class="p">});</span>

<span class="c1">// explicit for loop over boundary edges</span>
<span class="k">for</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Simplex</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;::</span><span class="n">boundary_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boundary_begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">boundary_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">normal</span><span class="p">();</span><span class="w">   </span><span class="c1">// normal direction to edge</span>
<span class="w">   </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">measure</span><span class="p">();</span><span class="w">  </span><span class="c1">// length of edge</span>
<span class="w">   </span><span class="c1">// ... all the standard Simplex API ...</span>
<span class="p">}</span>
</code></pre></div>
</div>
</div>
</li>
<li><p><strong>Elementary geometric entities</strong>: introduced templates <code class="code docutils literal notranslate"><span class="pre">Triangle</span></code>, <code class="code docutils literal notranslate"><span class="pre">Tetrahedron</span></code> and <code class="code docutils literal notranslate"><span class="pre">Segment</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id3">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span><code class="code docutils literal notranslate"><span class="pre">Triangle</span></code>, <code class="code docutils literal notranslate"><span class="pre">Tetrahedron</span></code>, <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> signature<a class="headerlink" href="#id3" title="Permalink to this code">¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Triangle</span><span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Simplex</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">Triangulation</span><span class="o">::</span><span class="n">embed_dim</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Tetrahedron</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Simplex</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Segment</span><span class="w">     </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Simplex</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Triangulation</span><span class="o">::</span><span class="n">embed_dim</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
</div>
</div>
<p>While <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> is a free geometric object, each of the above types have no meaning if not bounded to a triangulation, e.g. a <code class="xref py py-class docutils literal notranslate"><span class="pre">Triangle</span></code> exists only as part of a <code class="code docutils literal notranslate"><span class="pre">Triangulation&lt;2,</span> <span class="pre">EmbedDim&gt;</span></code> object.</p>
<p>In addition to the whole <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> API, the following methods related to connectivity information are available:</p>
<table class="docutils data align-default" id="id4">
<caption><span class="caption-text"><strong>Triangle specific API</strong></span><a class="headerlink" href="#id4" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 40.0%" />
<col style="width: 60.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">id()</span></code></p></td>
<td><p>the triangle id in the physical triangulation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">neighbors()</span></code></p></td>
<td><p>returns the ids of neighboring triangles.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">node_ids()</span></code></p></td>
<td><p>returns the ids of the triangle vertices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">on_boundary()</span></code></p></td>
<td><p>true if the triangle has at least one edge on the triangulation boundary.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">edge(int</span> <span class="pre">i)</span></code></p></td>
<td><dl class="simple">
<dt>returns the i-th edge as an <code class="code docutils literal notranslate"><span class="pre">EdgeType</span></code> instance. An <code class="code docutils literal notranslate"><span class="pre">EdgeType</span></code> inherits from <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;1,</span> <span class="pre">Triangulation::embed_dim&gt;</span></code>, i.e. it represents a geometrical segment, and provides the following:</dt><dd><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">id()</span></code>: the ID of the edge in the physical triangulation.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">node_ids()</span></code>: the ids of the nodes composing the edge.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">adjacent_cells()</span></code>: the ids of the cells (i.e., triangles) which share this edge.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">on_boundary()</span></code>: true if the edge is on boundary.</p></li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">edges_begin()/edges_end()</span></code></p></td>
<td><p>first and last iterator to triangle edges.</p></td>
</tr>
</tbody>
</table>
<p><code class="code docutils literal notranslate"><span class="pre">Tetrahedron</span></code> exposes a simlar interface, with the addition of iterators and access methods to each face of the tetrahedron. Check the <code class="code docutils literal notranslate"><span class="pre">Triangulation</span></code> code snippet below for a detailed exposition of the API.</p>
</li>
<li><p><strong>Triangulation</strong>: template <code class="code docutils literal notranslate"><span class="pre">Mesh&lt;int</span> <span class="pre">LocalDim,</span> <span class="pre">int</span> <span class="pre">EmbedDim&gt;</span></code> has been removed and replaced by the new <code class="code docutils literal notranslate"><span class="pre">Triangulation&lt;int</span> <span class="pre">LocalDim,</span> <span class="pre">int</span> <span class="pre">EmbedDim&gt;</span></code> type.</p>
<div class="literal-block-wrapper docutils container" id="id5">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>Triangulation signature<a class="headerlink" href="#id5" title="Permalink to this code">¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">LocalDim</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">EmbedDim</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Triangulation</span><span class="p">;</span>
</code></pre></div>
</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Tip</p>
<p>The main point of the <code class="code docutils literal notranslate"><span class="pre">Triangulation</span></code> data type is the exposition of iterators to logically iterate over different parts of the mesh. Moreover, the provided iterators are compliant to the <code class="code docutils literal notranslate"><span class="pre">std::bidirectional_iterator</span></code> concept, which let use any STL algorithm over <code class="code docutils literal notranslate"><span class="pre">Triangulation</span></code> iterator ranges. For instance, it is straightforward to compute the measure of the border:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="c1">// just one line, for a complex operation :)</span>
<span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_edges_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_edges_end</span><span class="p">(),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cell</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cell</span><span class="p">.</span><span class="n">measure</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>
</code></pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>This let us easily parallelize different operations, once we link fdaPDE to the <a class="reference external" href="https://oneapi-src.github.io/oneTBB/">oneTBB</a> library shipped by Intel, thanks to the STL support for parallel algorithms. It is immediate, for instance, to compute the measure of the mesh by a parallel <code class="code docutils literal notranslate"><span class="pre">std::reduce</span></code>.</p>
</div>
</div>
<p>Check the code snippet below for a detailed description of the exposed API:</p>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>Triangulation API<a class="headerlink" href="#id6" title="Permalink to this code">¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="c1">// a planar triangulation (the API below is also available for triangulated surfaces)</span>
<span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mesh</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">cells</span><span class="p">,</span><span class="w"> </span><span class="n">boundary</span><span class="p">);</span>
<span class="c1">// Triangulation&lt;2, 2&gt; will compute for you the edges, the neighboring structure and</span>
<span class="c1">// other connectivity informations</span>

<span class="n">mesh</span><span class="p">.</span><span class="n">cell</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">   </span><span class="c1">// request i-th cell as a Triangle&lt;2, 2&gt;</span>
<span class="n">mesh</span><span class="p">.</span><span class="n">node</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">   </span><span class="c1">// request i-th node</span>

<span class="c1">// a lot of other informations, such as matrix of edges, neighbors, etc. number of edges, cells,</span>
<span class="c1">// boundary edges and boundary nodes, triangulation bounding box, etc.</span>
<span class="c1">// check the source code for more details!</span>

<span class="c1">// iterators</span>
<span class="k">for</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;::</span><span class="n">cell_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">cells_begin</span><span class="p">();</span>
<span class="w">    </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">cells_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// all the interface of Triangle&lt;2, 2&gt; is accessible from the iterator it</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">measure</span><span class="p">();</span><span class="w">      </span><span class="c1">// measure of triangle</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">circumcenter</span><span class="p">();</span><span class="w"> </span><span class="c1">// circumcenter of triangle</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">cells_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">cells_end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cell</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// whatever complex operation on your cell (even the assembly of a differential weak form)</span>
<span class="p">});</span>
<span class="c1">// and the above can be paralellized thanks to the STL :)</span>

<span class="c1">// cycle over the border</span>
<span class="k">for</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;::</span><span class="n">boundary_edge_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_edges_begin</span><span class="p">();</span>
<span class="w">    </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_edges_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// all the interface of Triangle&lt;2, 2&gt;::EdgeType available from the iterator</span>

<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">measure</span><span class="p">();</span><span class="w">        </span><span class="c1">// length of edge</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">barycenter</span><span class="p">();</span><span class="w">     </span><span class="c1">// mid-point of the edge</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">adjacent_cells</span><span class="p">();</span><span class="w"> </span><span class="c1">// the id of the triangle sharing this edge</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// you can also iterate on</span>
<span class="c1">// - the whole set of edges with: edges_begin() / edges_end()</span>
<span class="c1">// - the boundary nodes with    : boundary_nodes_begin() / boundary_nodes_end()</span>

<span class="n">DVector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">locate</span><span class="p">(</span><span class="n">locs</span><span class="p">);</span><span class="w">               </span><span class="c1">// O(log(n_locs)) point location</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">patch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">node_patch</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="c1">// ids of all triangles having n as vertex</span>

<span class="c1">// 3D triangulation (tetrahedralizations)</span>
<span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mesh</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">cells</span><span class="p">,</span><span class="w"> </span><span class="n">boundary</span><span class="p">);</span>

<span class="c1">// all the interface of a Triangulation&lt;2, 2&gt; is available, with the additional capability</span>
<span class="c1">// of indexing and iterating over the faces of each tetrahedron</span>

<span class="k">for</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;::</span><span class="n">boundary_face_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_faces_begin</span><span class="p">();</span>
<span class="w">    </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_faces_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// all the interface of Tetrahedron&lt;3, 3&gt;::FaceType (i.e., a 3D triangle with connectivity infos)</span>
<span class="w">    </span><span class="c1">// available from the iterator it</span>

<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">normal</span><span class="p">();</span><span class="w">   </span><span class="c1">// normal direction to the face</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">measure</span><span class="p">();</span><span class="w">  </span><span class="c1">// area of the triangle</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">edge_ids</span><span class="p">();</span><span class="w"> </span><span class="c1">// global ids in the 3D triangulation of the edges making this triangle</span>

<span class="w">    </span><span class="c1">// you can in turn cicle on each 3D edge of the current boundary face it</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">jt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">edges_begin</span><span class="p">();</span><span class="w"> </span><span class="n">jt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">edges_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">jt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">       </span><span class="c1">// jt is a Simplex&lt;1, 3&gt; exposing also</span>
<span class="w">       </span><span class="n">jt</span><span class="o">-&gt;</span><span class="n">on_boundary</span><span class="p">();</span><span class="w"> </span><span class="c1">// well, this is true, we are iterating over the border :)</span>
<span class="w">       </span><span class="n">jt</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">();</span><span class="w">          </span><span class="c1">// id of the edge in the 3D triangulation</span>
<span class="w">       </span><span class="n">jt</span><span class="o">-&gt;</span><span class="n">node_ids</span><span class="p">();</span><span class="w">    </span><span class="c1">// ids of nodes composing the edge</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// for a 3D mesh, you can get also its surface mesh as a Triangulation&lt;2, 3&gt; instance</span>
<span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">surface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">surface</span><span class="p">();</span>

<span class="kt">double</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_faces_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_faces_end</span><span class="p">(),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">measure</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>
<span class="kt">double</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">cells_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">surface</span><span class="p">.</span><span class="n">cells_end</span><span class="p">(),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">measure</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>
<span class="c1">// and not surprisingly, p1 == p2 :)</span>
</code></pre></div>
</div>
</div>
</li>
<li><p><strong>Projection</strong>: template class <code class="code docutils literal notranslate"><span class="pre">Projection&lt;TriangulationType&gt;</span></code> implements an exact and a non-exact method for point projection over a <code class="code docutils literal notranslate"><span class="pre">Triangulation&lt;LocalDim,</span> <span class="pre">EmbedDim&gt;</span></code>. Given a free point <span class="math notranslate nohighlight">\(p\)</span>, the algorithm searches for the best approximation of <span class="math notranslate nohighlight">\(p\)</span> in the triangulation. In this sense, it works both for manifold and non-manifold domains (in the last case, the algorithm returns the point on the 2D/3D triangulation border which is nearest to <span class="math notranslate nohighlight">\(p\)</span>).</p>
<p>Computational complexity: let <span class="math notranslate nohighlight">\(N\)</span> be the number of cells and <span class="math notranslate nohighlight">\(n\)</span> the number of points to project.</p>
<ul class="simple">
<li><p>Exact version is <span class="math notranslate nohighlight">\(O(nN)\)</span>.</p></li>
<li><p>Assuming <span class="math notranslate nohighlight">\(n \gg N\)</span> (number of points to project much larger than number of cells), approximate version is <span class="math notranslate nohighlight">\(O(n \log(N))\)</span> (it was <span class="math notranslate nohighlight">\(O(nN)\)</span> in <code class="code docutils literal notranslate"><span class="pre">fdaPDE-1.1-17</span></code>).</p></li>
</ul>
<div class="info admonition">
<p class="admonition-title">Info</p>
<p>The approximate algorithm computes a <code class="code docutils literal notranslate"><span class="pre">KDTree</span></code> for fast locating the nearest mesh node to <span class="math notranslate nohighlight">\(p\)</span> (with computational cost <span class="math notranslate nohighlight">\(O(N \log(N))\)</span>. This cost is negligible if <span class="math notranslate nohighlight">\(n \gg N\)</span>, and performed just once ). Once the nearest point <span class="math notranslate nohighlight">\(q\)</span> is found, a search restricted in the patch of <span class="math notranslate nohighlight">\(q\)</span> is performed, i.e., in the set of cells having <span class="math notranslate nohighlight">\(q\)</span> as vertex (computing the patch costs <span class="math notranslate nohighlight">\(O(\log(N))\)</span>), therefore avoiding a brute force search over the entire mesh (which would cost <span class="math notranslate nohighlight">\(O(N)\)</span>). This is an approximate approach since for highly non-convex region the computed point might be not the nearest to <span class="math notranslate nohighlight">\(p\)</span>.</p>
</div>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>Projection API<a class="headerlink" href="#id7" title="Permalink to this code">¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">surface</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">cells</span><span class="p">,</span><span class="w"> </span><span class="n">boundary</span><span class="p">);</span>

<span class="n">DMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">points</span><span class="p">;</span><span class="w"> </span><span class="c1">// free points in 3D space</span>
<span class="c1">// perform projection (use C++ automatic template deduction + tag dispatching)</span>
<span class="n">DMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">proj_points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Projection</span><span class="p">(</span><span class="n">surface</span><span class="p">)(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">fdapde</span><span class="o">::</span><span class="n">Exact</span><span class="p">);</span>
<span class="n">DMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">proj_points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Projection</span><span class="p">(</span><span class="n">surface</span><span class="p">)(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">fdapde</span><span class="o">::</span><span class="n">NotExact</span><span class="p">);</span>

<span class="c1">// NotExact projection requires a O(N log(N)) initialization, this is done just once</span>
<span class="c1">// at first call. You can create a Projection instance and cache</span>
<span class="n">Projection</span><span class="o">&lt;</span><span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">project</span><span class="p">(</span><span class="n">surface</span><span class="p">);</span>
<span class="n">project</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">fdapde</span><span class="o">::</span><span class="n">NotExact</span><span class="p">);</span><span class="w"> </span><span class="c1">// silent initialization here</span>
<span class="n">project</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">fdapde</span><span class="o">::</span><span class="n">NotExact</span><span class="p">);</span><span class="w"> </span><span class="c1">// just perform fast approximate projection</span>

<span class="n">project</span><span class="p">(</span><span class="n">points</span><span class="p">);</span><span class="w"> </span><span class="c1">// defaults to approximate algorithm</span>
</code></pre></div>
</div>
</div>
</li>
</ul>
</li>
<li><p><strong>Minor changes</strong>:</p>
<ul>
<li><p><strong>Optimizers support for objective stopping criterion callback</strong>: if the objective functor provided to the optimizer exposes a method with the following signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><code><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">OptimizerType</span><span class="o">&gt;</span> <span class="nb">bool</span> <span class="n">opt_stopping_criterion</span><span class="p">(</span><span class="n">OptimizerType</span><span class="o">&amp;</span> <span class="n">opt</span><span class="p">);</span>
</code></pre></div>
</div>
<p>any optimizer in the optimization module will execute it to evaluate if convergence has been reached. Users of the optimization module can hence define objective functions with a custom stopping criterion (see, e.g., density estimation in fdaPDE-cpp).</p>
</li>
<li><p><strong>Binary matrix</strong>: binary matrices have proved to be extremely usefull for handling bitmasks and are getting more and more used in the codebase. The following additional methods are now exposed:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">;</span>
<span class="n">BinaryMatrix</span><span class="o">&lt;</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bitmask</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">);</span>

<span class="c1">// writable block expressions</span>
<span class="n">bitmask</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BinaryMatrix</span><span class="o">&lt;</span><span class="n">Dynamic</span><span class="o">&gt;::</span><span class="n">Ones</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="c1">// reshape operation</span>
<span class="n">bitmask</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// reshape bitmask to a 25 x 100 matrix (no-cost operation)</span>
<span class="n">bitmask</span><span class="p">.</span><span class="n">vector_view</span><span class="p">();</span><span class="w">    </span><span class="c1">// linearize the bitmask into a column vector (no-cost operation)</span>

<span class="c1">// returns all the indexes set to true/false in the bitmask: O(nm) operation</span>
<span class="n">bitmask</span><span class="p">.</span><span class="n">which</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w">  </span><span class="c1">// which true?</span>
<span class="n">bitmask</span><span class="p">.</span><span class="n">which</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"> </span><span class="c1">// which false?</span>
<span class="n">which</span><span class="p">(</span><span class="n">bitmask</span><span class="p">);</span><span class="w">       </span><span class="c1">// implicitly returns true indexes (R style)</span>
</code></pre></div>
</div>
</li>
</ul>
</li>
</ul>
<p><strong>cpp</strong></p>
<ul>
<li><p><strong>Density estimation</strong>: official support for density estimation models. Below the API exposed by the <code class="code docutils literal notranslate"><span class="pre">DensityEstimationBase</span></code> core class for the density module:</p>
<table class="docutils data align-default" id="id8">
<caption><span class="caption-text"><strong>DensityEstimationBase API</strong></span><a class="headerlink" href="#id8" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 40.0%" />
<col style="width: 60.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">n_obs()</span></code></p></td>
<td><p>number of active data locations. A data location is active if is it not masked.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">n_locs()</span></code></p></td>
<td><p>number of all data locations (e.g., the overall number of observations). It coincides with <code class="code docutils literal notranslate"><span class="pre">n_obs()</span></code> if no observation is masked.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">Psi()</span></code></p></td>
<td><p>the matrix <span class="math notranslate nohighlight">\(\Psi\)</span> (evaluation of spatial basis functions at data location) for space-only problems, the matrix <span class="math notranslate nohighlight">\(\Upsilon\)</span> for space-time problems (as defined in <em>Begu, B., Panzeri, S. (2022), Space-Time Density Estimation with Partial Differential Equation Regularization. PACS project. Pag 9.</em>)</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">Upsilon()</span></code></p></td>
<td><p>if some observation is masked, returns the matrix provided by <code class="code docutils literal notranslate"><span class="pre">Psi()</span></code> where rows corresponding to masked observations are set to zero, otherwise is equivalent to calling <code class="code docutils literal notranslate"><span class="pre">Psi()</span></code>. Upper models should mainly interact with this method, instead of directly calling <code class="code docutils literal notranslate"><span class="pre">Psi()</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">PsiQuad()</span></code></p></td>
<td><p>the matrix of evaluations of the reference basis system at the quadrature nodes. Already tensorized for space-time problems.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">w()</span></code></p></td>
<td><p>weights of the quadrature rule used for the approximation of <span class="math notranslate nohighlight">\(\int_{\Omega} e^g\)</span>. Already tensorized for space-time problems.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">int_exp(const</span> <span class="pre">DVector&lt;double&gt;&amp;</span> <span class="pre">g)</span></code></p></td>
<td><p>evaluation of <span class="math notranslate nohighlight">\(\int_{\Omega} e^g\)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">int_exp()</span></code></p></td>
<td><p>evaluation of <span class="math notranslate nohighlight">\(\int_{\Omega} e^{\hat g}\)</span>, where <span class="math notranslate nohighlight">\(\hat g\)</span> is the current estimation of the log density field.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">grad_int_exp(const</span> <span class="pre">DVector&lt;double&gt;&amp;</span> <span class="pre">g)</span></code></p></td>
<td><p>evaluation of the gradient of <span class="math notranslate nohighlight">\(\int_{\Omega} e^g\)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">grad_int_exp()</span></code></p></td>
<td><p>evaluation of the gradient of <span class="math notranslate nohighlight">\(\int_{\Omega} e^{\hat g}\)</span>, where <span class="math notranslate nohighlight">\(\hat g\)</span> is the current estimation of the log density field.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">g()</span></code></p></td>
<td><p>expansion coefficient vector of the log density field.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">f()</span></code></p></td>
<td><p>expansion coefficient vector of the density field, e.g. <span class="math notranslate nohighlight">\(f = e^g\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">masked_obs()</span></code></p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">BinaryVector&lt;Dynamic&gt;</span></code> of masked observations.</p></td>
</tr>
</tbody>
</table>
<p>As always, in addition, a model inheriting from <code class="code docutils literal notranslate"><span class="pre">DensityEstimationBase</span></code> has access to the specific API induced by the choosen regularization. Check the source code for details.</p>
<div class="info admonition">
<p class="admonition-title">The masking mechanism</p>
<p>This is something already shown in February 2024. At the statistical level, “masking” means to remove some observations (the masked ones) from the fitting. This corresponds to set to zero all the rows of the matrix <span class="math notranslate nohighlight">\(\Psi\)</span> (or <span class="math notranslate nohighlight">\(\Upsilon\)</span>) corresponding to masked observations. This mechanism is used, for instance, by the <code class="code docutils literal notranslate"><span class="pre">KCV</span></code> class to perform CV selection of the smoothing parameters.</p>
<p>By doing so, all models inheriting from <code class="code docutils literal notranslate"><span class="pre">DensityEstimationBase</span></code> have immediate support for smoothing parameter selection by K-fold Cross Validation.</p>
</div>
<p>Class <code class="code docutils literal notranslate"><span class="pre">DEPDE</span></code> implements the density estimation model shown in <em>Ferraccioli, F., Arnone, E., Finos, L., Ramsay, J.O., Sangalli, L.M. (2021), Nonparametric density estimation over complicated domains, Journal of the Royal Statistical Society</em> (space-only) and <em>Begu, B., Panzeri, S., Arnone, E., Carey, M., and Sangalli, L.M. (2024), A nonparametric penalized likelihood approach to density estimation of space-time point patterns, Spatial Statistics</em> (space-time).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RegularizationType_</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DEPDE</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">DensityEstimationBase</span><span class="o">&lt;</span><span class="n">DEPDE</span><span class="o">&lt;</span><span class="n">RegularizationType_</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">RegularizationType_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>
</code></pre></div>
</div>
<p>Because the resolution strategy for a density estimation model is a penalized log-likelihood minimization, <code class="xref py py-class docutils literal notranslate"><span class="pre">DEPDE</span></code> exposes an interface compatible with the optimization module, i.e. it acts exactly as an optimizer objective function (see the optimization module API for details).</p>
<table class="docutils data align-default" id="id9">
<caption><span class="caption-text"><strong>DEPDE API</strong></span><a class="headerlink" href="#id9" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 40.0%" />
<col style="width: 60.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">operator(const</span> <span class="pre">DVector&lt;double&gt;&amp;</span> <span class="pre">g)</span></code></p></td>
<td><p>evaluates the penalized log-likelihood functional at <span class="math notranslate nohighlight">\(g\)</span>, i.e. computes <span class="math notranslate nohighlight">\(L(g) = - 1^\top \Upsilon g + \int_{\Omega} e^g + g^\top P_{\lambda} g\)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">derive()</span></code></p></td>
<td><p>returns a <code class="code docutils literal notranslate"><span class="pre">std::function&lt;DVector(const</span> <span class="pre">DVector&lt;double&gt;&amp;)&gt;</span></code> encoding the gradient of the penalized log-likelihood functional.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">bool</span> <span class="pre">opt_stopping_criterion(OptimizerType&amp;)</span></code></p></td>
<td><p>stops the optimization algorithm if the relative difference between the log-likelihood or the penalized log-likelihood is below a user defined tolerance (defaults to <span class="math notranslate nohighlight">\(10^{-5}\)</span>).</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">set_tolerance(double)</span></code></p></td>
<td><p>sets the tolerance for the custom stopping criterion (the one triggered by <code class="code docutils literal notranslate"><span class="pre">opt_stopping_criterion()</span></code>).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">set_g_init(const</span> <span class="pre">DMatrix&lt;double&gt;&amp;)</span></code></p></td>
<td><p>sets the initial log-density expansion coefficient vector.</p>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">DEPDE</span></code> does not compute any initialization density (e.g., by heat-process). Instead, it requests the initialization point, which must be externally computed.</p>
</div>
</td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">set_optimizer(OptimizerType&amp;&amp;)</span></code></p></td>
<td><p>sets the optimization algorithm for the minimization of the penalized log-likelihood functional <span class="math notranslate nohighlight">\(L(g)\)</span>. The optimizer is internally type-erased.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">init()</span></code></p></td>
<td><p>initializes the model stack.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">solve()</span></code></p></td>
<td><p>triggers the optimizer for the minimization of the penalized log-likelihood.</p></td>
</tr>
</tbody>
</table>
<p>Check the code snippet below for the provided API:</p>
<div class="example admonition">
<p class="admonition-title">Example</p>
<div class="literal-block-wrapper docutils container" id="id10">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>DEPDE API<a class="headerlink" href="#id10" title="Permalink to this code">¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="c1">// assume mesh and laplacian penalty already defined...</span>

<span class="c1">// space-only model</span>
<span class="n">DEPDE</span><span class="o">&lt;</span><span class="n">SpaceOnly</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">penalty</span><span class="p">);</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_lambda_D</span><span class="p">(</span><span class="mf">0.1</span><span class="p">);</span>

<span class="c1">// data in point-pattern processes coincide with locations</span>
<span class="n">BlockFrame</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">df</span><span class="p">;</span>
<span class="n">df</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SPACE_LOCS</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>

<span class="n">model</span><span class="p">.</span><span class="n">set_tolerance</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">);</span><span class="w"> </span><span class="c1">// set tolerance on custom stopping criterion</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">df</span><span class="p">);</span>

<span class="c1">// set optimization algorithm (here you have access to the whole optimization API)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">max_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span>
<span class="kt">double</span><span class="w"> </span><span class="n">opt_tolerance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e-5</span><span class="p">;</span><span class="w"> </span><span class="c1">// set optimizer tolerance (looks for the norm of the objective gradient)</span>
<span class="kt">double</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e-2</span><span class="p">;</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_optimizer</span><span class="p">(</span><span class="n">BFGS</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">max_iter</span><span class="p">,</span><span class="w"> </span><span class="n">opt_tolerance</span><span class="p">,</span><span class="w"> </span><span class="n">step</span><span class="p">});</span><span class="w"> </span><span class="c1">// optimizer must be Dynamic</span>

<span class="c1">// gradient descent with adaptive step</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_optimizer</span><span class="p">(</span><span class="n">GradientDescent</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="n">BacktrackingLineSearch</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">max_iter</span><span class="p">,</span><span class="w"> </span><span class="n">opt_tolerance</span><span class="p">,</span><span class="w"> </span><span class="n">step</span><span class="p">});</span>
<span class="c1">// in general, you can set any optimization algorithm in the optimization module</span>

<span class="c1">// initialize and solve</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_g_init</span><span class="p">(...);</span><span class="w"> </span><span class="c1">// optimization algorithm init point</span>
<span class="n">model</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
<span class="n">model</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>

<span class="n">model</span><span class="p">.</span><span class="n">g</span><span class="p">();</span><span class="w"> </span><span class="c1">// estimated log-density field</span>

<span class="c1">// you can also approach the fitting as a pure optimization problem (emphasis on the optimizer)</span>

<span class="n">BFGS</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="n">WolfeLineSearch</span><span class="o">&gt;</span><span class="w"> </span><span class="n">optimizer</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,</span><span class="w"> </span><span class="n">opt_tolerance</span><span class="p">,</span><span class="w"> </span><span class="n">step</span><span class="p">);</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">g_init</span><span class="p">);</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">optimum</span><span class="p">();</span><span class="w"> </span><span class="c1">// estimated log-density field</span>

<span class="c1">// and by just changing the RegularizetionType template, you get space-time :)</span>
<span class="n">DEPDE</span><span class="o">&lt;</span><span class="n">SpaceTimeSeparable</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">penalty_space</span><span class="p">,</span><span class="w"> </span><span class="n">penalty_time</span><span class="p">);</span>
<span class="c1">// all the API above stays valid</span>
</code></pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>DEPDE KFold-CV API<a class="headerlink" href="#id11" title="Permalink to this code">¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="c1">// assume mesh and laplacian penalty already defined...</span>

<span class="n">DEPDE</span><span class="o">&lt;</span><span class="n">SpaceOnly</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">penalty</span><span class="p">);</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">df</span><span class="p">);</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_optimizer</span><span class="p">(</span><span class="n">BFGS</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="n">WolfeLineSearch</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">max_iter</span><span class="p">,</span><span class="w"> </span><span class="n">opt_tolerance</span><span class="p">,</span><span class="w"> </span><span class="n">step</span><span class="p">});</span>

<span class="kt">int</span><span class="w"> </span><span class="n">n_folds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdapde</span><span class="o">::</span><span class="n">random_seed</span><span class="p">;</span>
<span class="n">KCV</span><span class="w"> </span><span class="nf">kcv</span><span class="p">(</span><span class="n">n_folds</span><span class="p">,</span><span class="w"> </span><span class="n">seed</span><span class="p">);</span>

<span class="n">DMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lambda_grid</span><span class="p">;</span><span class="w"> </span><span class="c1">// the grid of smoothing parameters to explore</span>
<span class="n">DMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">g_init_grid</span><span class="p">;</span><span class="w"> </span><span class="c1">// for each value of lambda, the initial density field (computed in some way)</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_g_init</span><span class="p">(</span><span class="n">g_init_grid</span><span class="p">);</span>

<span class="c1">// calibrate the model</span>
<span class="n">kcv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">lambda_grid</span><span class="p">);</span><span class="w"> </span><span class="c1">// uses DEPDE::CVScore scoring function, see below for details</span>

<span class="c1">// at the end you get</span>
<span class="n">kcv</span><span class="p">.</span><span class="n">avg_scores</span><span class="p">();</span>
<span class="n">kcv</span><span class="p">.</span><span class="n">std_scores</span><span class="p">();</span>
<span class="n">kcv</span><span class="p">.</span><span class="n">optimum</span><span class="p">();</span><span class="w"> </span><span class="c1">// optimal smoothing parameter</span>
</code></pre></div>
</div>
</div>
<div class="info admonition">
<p class="admonition-title">Info</p>
<p><code class="code docutils literal notranslate"><span class="pre">DEPDE</span></code> internally defines its cross-validation scoring index as a functor of type <code class="code docutils literal notranslate"><span class="pre">DEPDE::CVScore</span></code>, exposing a call operator compatible with the <code class="code docutils literal notranslate"><span class="pre">KCV</span></code> requirement. <code class="code docutils literal notranslate"><span class="pre">DEPDE::CVScore</span></code> implements Equation (1.18) of <em>Begu, B., Panzeri, S. (2022), Space-Time Density Estimation with Partial Differential Equation Regularization. PACS project. Pag 17.</em></p>
</div>
<div class="tip admonition">
<p class="admonition-title">Tip</p>
<p>When a model of type <code class="code docutils literal notranslate"><span class="pre">ModelType</span></code> exposes a public type <code class="code docutils literal notranslate"><span class="pre">ModelType::CVScore</span></code>, calling <code class="code docutils literal notranslate"><span class="pre">KCV::fit(model,</span> <span class="pre">lambda_grid)</span></code> fallbacks to the use of <code class="code docutils literal notranslate"><span class="pre">ModelType::CVScore</span></code> as cross validation index (rises a static assert otherwise). Specifically, <code class="code docutils literal notranslate"><span class="pre">ModelType::CVScore</span></code> must expose a constructor with the following signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="n">CVScore</span><span class="p">(</span><span class="n">ModelType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
</code></pre></div>
</div>
<p>and expose a call operator</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="kt">double</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">fold</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lambda</span><span class="p">,</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryVector</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">train_mask</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryVector</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">test_mask</span><span class="p">);</span>
</code></pre></div>
</div>
</div>
</div>
</li>
</ul>
<p><strong>R (base)</strong></p>
<p>Be prepared, almost ready (at least on paper).</p>







  
  




  



                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2024, fdaPDE.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    8.2.3.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.expand", "navigation.sections"], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
      
        <script src="../_static/sphinx_immaterial_theme.32136f45f91ae6956.min.js?v=a7a9472a"></script>
        <script id="MathJax-script" src="../_static/mathjax/tex-mml-chtml.js?v=cadf963e"></script>
    
  </body>
</html>