


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="">
    
    
      
        <title>May 2024 - fdaPDE  documentation</title>
      
    
    
      
      


    
    
      
    
    
      
        
        
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="../_static/sphinx_immaterial_theme.243c798c14787bf0e.min.css?v=a4497153" />
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../index.html" title="fdaPDE  documentation" class="md-header__button md-logo" aria-label="fdaPDE  documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            fdaPDE  documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              May 2024
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
                
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="fdaPDE  documentation" class="md-nav__button md-logo" aria-label="fdaPDE  documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>
    </a>
    fdaPDE  documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/tut_1.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Example 1:<wbr> A non-<wbr>linear diffusion reaction problem
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/tut_2.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Example 2:<wbr> The Heat equation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/tut_5.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Example 3:<wbr> SUPG for advection dominated equations
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/tut_4.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Example 4:<wbr> The Stokes problem
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/alpha_testing.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Alpha testing fda<wbr>PDE 2.<wbr>0 <wbr>[cpp]
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
                
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" hidden>
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary">
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset" role="main">
                
                
                  
  



<h1 id="may-2024">May 2024<a class="headerlink" href="#may-2024" title="Link to this heading">Â¶</a></h1>
<p>Reached 10K lines of code.</p>
<div class="success admonition">
<p class="admonition-title">RcppEigen version upgraded to 0.3.4</p>
<p><code class="code docutils literal notranslate"><span class="pre">RcppEigen</span></code> has been updated to Eigen v3.4.0 (version 0.3.4 of the <code class="code docutils literal notranslate"><span class="pre">RcppEigen</span></code> package released on CRAN on 2024-02-28). There are no more restrictions for using Eigen v3.3.9, therefore the whole C++ codebase will upgrade the Eigen version to the 3.4.0. Code will not compile anymore with Eigen v3.3.9 as it already makes use of <a class="reference external" href="https://eigen.tuxfamily.org/dox/group__TutorialSlicingIndexing.html">slicing, indexing</a>  and <a class="reference external" href="https://eigen.tuxfamily.org/dox/group__TutorialSTL.html">Eigen support for STL iterators</a> available only in the 3.4 version.</p>
<p>The fdaPDE-R package DESCRIPTION and the various CMakeLists.txt files have been updated. femR will need to update its DESCRIPTION file when aligned to the mainstream fdaPDE-core library.</p>
<p>As a consequence of this upgrade, there are no limitations for using the C++20 standard, as announced in February 2024.</p>
</div>
<div class="danger admonition">
<p class="admonition-title">Warnings are errors</p>
<p>From this update on, to achieve high-quality code, tests are compiled with the options <code class="code docutils literal notranslate"><span class="pre">-Wall</span> <span class="pre">-Wpedantic</span> <span class="pre">-Wextra</span> <span class="pre">-Werror</span></code>. This setting enables the majority of the interesting warnings, and considers warnings as errors (<code class="code docutils literal notranslate"><span class="pre">-Werror</span></code> flag). That said, warnings cannot be ignored anymore. This options should help also for a less painfull interface with the CRAN rules.</p>
</div>
<p><strong>core</strong></p>
<ul>
<li><p><strong>geometry</strong>: the geometry module is under a major rewriting, and is the first step toward a more general core library system. While work is still in progress, here a list of the already official features:</p>
<div class="abstract admonition">
<p class="admonition-title">Nomenclature</p>
<p>Inside the geometry module, we will refer with <em>cell</em> what in finite element analysis is usually named element, that is, depending on the dimensionality of the domain, a <em>cell</em> will be a segment (1D, 1.5D), a triangle (2D, 2.5D) or a tetrahedron (3D).</p>
<p>We will name <em>node</em> a vertex of a <em>cell</em>. For triangular meshes, the name <em>edge</em> refers to a boundary segment of a triangle. For tetrahedral meshes, the name <em>face</em> denotes a boundary triangle of a tetrahedron, while the name <em>edge</em> refer to a boundary segment of such triangle, i.e. is a 3D segment (to be cristal clear, a tetrahedron has 4 faces and 6 edges).</p>
</div>
<ul class="simple">
<li><p>template <code class="code docutils literal notranslate"><span class="pre">Element&lt;int</span> <span class="pre">LocalDim,</span> <span class="pre">int</span> <span class="pre">EmbedDim&gt;</span></code> has been removed. <code class="code docutils literal notranslate"><span class="pre">Element</span></code> was a generic way to indicate a single segment/triangle/tetrahedron inside a mesh. Its presence was a problem, as the resulting interface was a bit controversial (for instance, a triangle had to define both a concept of face and of edge, which in this case are equivalent). Moreover, it was impossible to work on a simple cell without having an entire mesh structure, which was a bit annoying.</p></li>
</ul>
<p>The following structure has been introduced:</p>
<ul>
<li><p><strong>Simplex</strong>: <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> represents a generic <a class="reference external" href="https://en.wikipedia.org/wiki/Simplex">simplex</a> embedded in an <code class="code docutils literal notranslate"><span class="pre">EmbedDim</span></code>-dimensional space. The template parameter <code class="code docutils literal notranslate"><span class="pre">Order</span></code> sets the order of the simplex, e.g. depdending on its value, <code class="code docutils literal notranslate"><span class="pre">Simplex</span></code> represents a segment (<code class="code docutils literal notranslate"><span class="pre">Order</span></code> = 1), a triangle (<code class="code docutils literal notranslate"><span class="pre">Order</span></code> = 2) or a tetrahedron (<code class="code docutils literal notranslate"><span class="pre">Order</span></code> = 3). Higher orders are available, but from a geometrical viewpoint there is no interest in having <code class="code docutils literal notranslate"><span class="pre">Order</span> <span class="pre">&gt;</span> <span class="pre">3</span></code>. The following geometric operations are available on a simplex:</p>
<table class="docutils data align-default" id="id1">
<caption><span class="caption-text"><strong>Simplex API</strong></span><a class="headerlink" href="#id1" title="Link to this table">Â¶</a></caption>
<colgroup>
<col style="width: 40.0%" />
<col style="width: 60.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">measure()</span></code></p></td>
<td><p>measure of the simplex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">bounding_box()</span></code></p></td>
<td><p>returns the smallest rectangle containing the simplex.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">barycenter()</span></code></p></td>
<td><p>returns the midpoint (center of mass) of the simplex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">barycentric_coords(const</span> <span class="pre">NodeType&amp;</span> <span class="pre">p)</span></code></p></td>
<td><p>given a point <span class="math notranslate nohighlight">\(p\)</span>, rewrites it in the barycentric coordinate system of the simplex.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">circumcenter()</span></code></p></td>
<td><p>returns the center of the (hyper)-sphere passing through the vertices of the simplex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">circumradius()</span></code></p></td>
<td><p>returns the radius of the (hyper)-sphere passing through the vertices of the simplex.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">contains(const</span> <span class="pre">NodeType&amp;</span> <span class="pre">p)</span></code></p></td>
<td><p>given a point <span class="math notranslate nohighlight">\(p\)</span> determines if the point is inside, on a boundary cell, on a vertex or outside of the simplex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">supporting_plane()</span></code></p></td>
<td><p>the <code class="code docutils literal notranslate"><span class="pre">HyperPlane&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> passing through the simplex.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">normal()</span></code></p></td>
<td><p>the normal direction to the simplex (meaningfull only if <code class="code docutils literal notranslate"><span class="pre">Order</span> <span class="pre">!=</span> <span class="pre">EmbedDim</span></code>, otherwise returns zero).</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">nearest(const</span> <span class="pre">NodeType&amp;</span> <span class="pre">p)</span></code></p></td>
<td><p>given a free point <span class="math notranslate nohighlight">\(p\)</span>, finds the best approximation of <span class="math notranslate nohighlight">\(p\)</span> in the simplex (e.g., the point in the simplex which is nearest to <span class="math notranslate nohighlight">\(p\)</span>).</p></td>
</tr>
</tbody>
</table>
<p><code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> also provides a <code class="code docutils literal notranslate"><span class="pre">boundary_iterator</span></code> type which let iterate over the boundary cells of the simplex as <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">EmbedDim&gt;</span></code> simplices (which means that you have all the API above for each boundary cell).</p>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> data type is mainly for internal usage. It is in turn inherited by other high-level concepts. Check the <code class="code docutils literal notranslate"><span class="pre">Triangle</span></code>, <code class="code docutils literal notranslate"><span class="pre">Tetrahedron</span></code>, etc. types below. The point of <code class="code docutils literal notranslate"><span class="pre">Simplex</span></code> is to be a free geometric object, i.e. without any connectivity information related to the presence of an underlying triangulation. Neverthless, having the ability to work on a free geometric object turns out to be usefull in many applications.</p>
</div>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>Simplex API<a class="headerlink" href="#id2" title="Permalink to this code">Â¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="c1">// create a 2D triangle (Simplex of order 2, embedded in a 2D space)</span>
<span class="n">SMatrix</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vertices</span><span class="p">;</span>
<span class="n">vertices</span><span class="w"> </span><span class="o">&lt;&lt;</span>
<span class="w">   </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.8</span><span class="p">;</span>
<span class="n">Simplex</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">triangle</span><span class="p">(</span><span class="n">vertices</span><span class="p">);</span>

<span class="n">triangle</span><span class="p">.</span><span class="n">measure</span><span class="p">();</span>
<span class="n">triangle</span><span class="p">.</span><span class="n">circumcenter</span><span class="p">();</span>
<span class="c1">// ... see the table above ...</span>

<span class="c1">// compute the perimeter of the triangle using STL algorithms :)</span>
<span class="kt">double</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span>
<span class="w">   </span><span class="n">triangle</span><span class="p">.</span><span class="n">boundary_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">triangle</span><span class="p">.</span><span class="n">boundary_end</span><span class="p">(),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">perimeter</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">perimeter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">measure</span><span class="p">();</span>
<span class="w">   </span><span class="p">});</span>

<span class="c1">// explicit for loop over boundary edges</span>
<span class="k">for</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Simplex</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;::</span><span class="n">boundary_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boundary_begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">boundary_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">normal</span><span class="p">();</span><span class="w">   </span><span class="c1">// normal direction to edge</span>
<span class="w">   </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">measure</span><span class="p">();</span><span class="w">  </span><span class="c1">// length of edge</span>
<span class="w">   </span><span class="c1">// ... all the standard Simplex API ...</span>
<span class="p">}</span>
</code></pre></div>
</div>
</div>
</li>
<li><p><strong>Elementary geometric entities</strong>: introduced templates <code class="code docutils literal notranslate"><span class="pre">Triangle</span></code>, <code class="code docutils literal notranslate"><span class="pre">Tetrahedron</span></code> and <code class="code docutils literal notranslate"><span class="pre">Segment</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id3">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span><code class="code docutils literal notranslate"><span class="pre">Triangle</span></code>, <code class="code docutils literal notranslate"><span class="pre">Tetrahedron</span></code>, <code class="code docutils literal notranslate"><span class="pre">Segment</span></code> signature<a class="headerlink" href="#id3" title="Permalink to this code">Â¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Triangle</span><span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Simplex</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">Triangulation</span><span class="o">::</span><span class="n">embed_dim</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Tetrahedron</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Simplex</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Segment</span><span class="w">     </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Simplex</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Triangulation</span><span class="o">::</span><span class="n">embed_dim</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
</div>
</div>
<p>While <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> is a free geometric object, each of the above types have no meaning if not bounded to a triangulation, e.g. a <code class="xref py py-class docutils literal notranslate"><span class="pre">Triangle</span></code> exists only as part of a <code class="code docutils literal notranslate"><span class="pre">Triangulation&lt;2,</span> <span class="pre">EmbedDim&gt;</span></code> object.</p>
<p>In addition to the whole <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;Order,</span> <span class="pre">EmbedDim&gt;</span></code> API, the following methods related to connectivity information are available:</p>
<table class="docutils data align-default" id="id4">
<caption><span class="caption-text"><strong>Triangle specific API</strong></span><a class="headerlink" href="#id4" title="Link to this table">Â¶</a></caption>
<colgroup>
<col style="width: 40.0%" />
<col style="width: 60.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">id()</span></code></p></td>
<td><p>the triangle id in the physical triangulation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">neighbors()</span></code></p></td>
<td><p>returns the ids of neighboring triangles.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">node_ids()</span></code></p></td>
<td><p>returns the ids of the triangle vertices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">on_boundary()</span></code></p></td>
<td><p>true if the triangle has at least one edge on the triangulation boundary.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">edge(int</span> <span class="pre">i)</span></code></p></td>
<td><dl class="simple">
<dt>returns the i-th edge as an <code class="code docutils literal notranslate"><span class="pre">EdgeType</span></code> instance. An <code class="code docutils literal notranslate"><span class="pre">EdgeType</span></code> inherits from <code class="code docutils literal notranslate"><span class="pre">Simplex&lt;1,</span> <span class="pre">Triangulation::embed_dim&gt;</span></code>, i.e. it represents a geometrical segment, and provides the following:</dt><dd><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">id()</span></code>: the ID of the edge in the physical triangulation.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">node_ids()</span></code>: the ids of the nodes composing the edge.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">adjacent_cells()</span></code>: the ids of the cells (i.e., triangles) which share this edge.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">on_boundary()</span></code>: true if the edge is on boundary.</p></li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">edges_begin()/edges_end()</span></code></p></td>
<td><p>first and last iterator to triangle edges.</p></td>
</tr>
</tbody>
</table>
<p><code class="code docutils literal notranslate"><span class="pre">Tetrahedron</span></code> exposes a simlar interface, with the addition of iterators and access methods to each face of the tetrahedron. Check the <code class="code docutils literal notranslate"><span class="pre">Triangulation</span></code> code snippet below for a detailed exposition of the API.</p>
</li>
<li><p><strong>Triangulation</strong>: template <code class="code docutils literal notranslate"><span class="pre">Mesh&lt;int</span> <span class="pre">LocalDim,</span> <span class="pre">int</span> <span class="pre">EmbedDim&gt;</span></code> has been removed and replaced by the new <code class="code docutils literal notranslate"><span class="pre">Triangulation&lt;int</span> <span class="pre">LocalDim,</span> <span class="pre">int</span> <span class="pre">EmbedDim&gt;</span></code> type.</p>
<div class="literal-block-wrapper docutils container" id="id5">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>Triangulation signature<a class="headerlink" href="#id5" title="Permalink to this code">Â¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">LocalDim</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">EmbedDim</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Triangulation</span><span class="p">;</span>
</code></pre></div>
</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Tip</p>
<p>The main point of the <code class="code docutils literal notranslate"><span class="pre">Triangulation</span></code> data type is the exposition of iterators to logically iterate over different parts of the mesh. Moreover, the provided iterators are compliant to the <code class="code docutils literal notranslate"><span class="pre">std::bidirectional_iterator</span></code> concept, which let use any STL algorithm over <code class="code docutils literal notranslate"><span class="pre">Triangulation</span></code> iterator ranges. For instance, it is straightforward to compute the measure of the border:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="c1">// just one line, for a complex operation :)</span>
<span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_edges_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_edges_end</span><span class="p">(),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cell</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cell</span><span class="p">.</span><span class="n">measure</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>
</code></pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>This let us easily parallelize different operations, once we link fdaPDE to the <a class="reference external" href="https://oneapi-src.github.io/oneTBB/">oneTBB</a> library shipped by Intel, thanks to the STL support for parallel algorithms. It is immediate, for instance, to compute the measure of the mesh by a parallel <code class="code docutils literal notranslate"><span class="pre">std::reduce</span></code>.</p>
</div>
</div>
<p>Check the code snippet below for a detailed description of the exposed API:</p>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>Triangulation API<a class="headerlink" href="#id6" title="Permalink to this code">Â¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="c1">// a planar triangulation (the API below is also available for triangulated surfaces)</span>
<span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mesh</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">cells</span><span class="p">,</span><span class="w"> </span><span class="n">boundary</span><span class="p">);</span>
<span class="c1">// Triangulation&lt;2, 2&gt; will compute for you the edges, the neighboring structure and</span>
<span class="c1">// other connectivity informations</span>

<span class="n">mesh</span><span class="p">.</span><span class="n">cell</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">   </span><span class="c1">// request i-th cell as a Triangle&lt;2, 2&gt;</span>
<span class="n">mesh</span><span class="p">.</span><span class="n">node</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">   </span><span class="c1">// request i-th node</span>

<span class="c1">// a lot of other informations, such as matrix of edges, neighbors, etc. number of edges, cells,</span>
<span class="c1">// boundary edges and boundary nodes, triangulation bounding box, etc.</span>
<span class="c1">// check the source code for more details!</span>

<span class="c1">// iterators</span>
<span class="k">for</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;::</span><span class="n">cell_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">cells_begin</span><span class="p">();</span>
<span class="w">    </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">cells_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// all the interface of Triangle&lt;2, 2&gt; is accessible from the iterator it</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">measure</span><span class="p">();</span><span class="w">      </span><span class="c1">// measure of triangle</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">circumcenter</span><span class="p">();</span><span class="w"> </span><span class="c1">// circumcenter of triangle</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">cells_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">cells_end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cell</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// whatever complex operation on your cell (even the assembly of a differential weak form)</span>
<span class="p">});</span>
<span class="c1">// and the above can be paralellized thanks to the STL :)</span>

<span class="c1">// cycle over the border</span>
<span class="k">for</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;::</span><span class="n">boundary_edge_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_edges_begin</span><span class="p">();</span>
<span class="w">    </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_edges_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// all the interface of Triangle&lt;2, 2&gt;::EdgeType available from the iterator</span>

<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">measure</span><span class="p">();</span><span class="w">        </span><span class="c1">// length of edge</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">barycenter</span><span class="p">();</span><span class="w">     </span><span class="c1">// mid-point of the edge</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">adjacent_cells</span><span class="p">();</span><span class="w"> </span><span class="c1">// the id of the triangle sharing this edge</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// you can also iterate on</span>
<span class="c1">// - the whole set of edges with: edges_begin() / edges_end()</span>
<span class="c1">// - the boundary nodes with    : boundary_nodes_begin() / boundary_nodes_end()</span>

<span class="n">DVector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">locate</span><span class="p">(</span><span class="n">locs</span><span class="p">);</span><span class="w">               </span><span class="c1">// O(log(n_locs)) point location</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">patch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">node_patch</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="c1">// ids of all triangles having n as vertex</span>

<span class="c1">// 3D triangulation (tetrahedralizations)</span>
<span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mesh</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">cells</span><span class="p">,</span><span class="w"> </span><span class="n">boundary</span><span class="p">);</span>

<span class="c1">// all the interface of a Triangulation&lt;2, 2&gt; is available, with the additional capability</span>
<span class="c1">// of indexing and iterating over the faces of each tetrahedron</span>

<span class="k">for</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Triangulation</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;::</span><span class="n">boundary_face_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_faces_begin</span><span class="p">();</span>
<span class="w">    </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_faces_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// all the interface of Tetrahedron&lt;3, 3&gt;::FaceType (i.e., a 3D triangle with connectivity infos)</span>
<span class="w">    </span><span class="c1">// available from the iterator it</span>

<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">normal</span><span class="p">();</span><span class="w">   </span><span class="c1">// normal direction to the face</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">measure</span><span class="p">();</span><span class="w">  </span><span class="c1">// area of the triangle</span>
<span class="w">    </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">edge_ids</span><span class="p">();</span><span class="w"> </span><span class="c1">// global ids in the 3D triangulation of the edges making this triangle</span>

<span class="w">    </span><span class="c1">// you can in turn cicle on each 3D edge of the current boundary face it</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">jt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">edges_begin</span><span class="p">();</span><span class="w"> </span><span class="n">jt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">edges_end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">jt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">       </span><span class="c1">// jt is a Simplex&lt;1, 3&gt; exposing also</span>
<span class="w">       </span><span class="n">jt</span><span class="o">-&gt;</span><span class="n">on_boundary</span><span class="p">();</span><span class="w"> </span><span class="c1">// well, this is true, we are iterating over the border :)</span>
<span class="w">       </span><span class="n">jt</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">();</span><span class="w">          </span><span class="c1">// id of the edge in the 3D triangulation</span>
<span class="w">       </span><span class="n">jt</span><span class="o">-&gt;</span><span class="n">node_ids</span><span class="p">();</span><span class="w">    </span><span class="c1">// ids of nodes composing the edge</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// for a 3D mesh, you can get also its surface mesh as a Triangulation&lt;2, 3&gt; instance</span>
<span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">surface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">surface</span><span class="p">();</span>

<span class="kt">double</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_faces_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">mesh</span><span class="p">.</span><span class="n">boundary_faces_end</span><span class="p">(),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">measure</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>
<span class="kt">double</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">cells_begin</span><span class="p">(),</span><span class="w"> </span><span class="n">surface</span><span class="p">.</span><span class="n">cells_end</span><span class="p">(),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">   </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">measure</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>
<span class="c1">// and not surprisingly, p1 == p2 :)</span>
</code></pre></div>
</div>
</div>
</li>
<li><p><strong>Projection</strong>: template class <code class="code docutils literal notranslate"><span class="pre">Projection&lt;TriangulationType&gt;</span></code> implements an exact and a non-exact method for point projection over a <code class="code docutils literal notranslate"><span class="pre">Triangulation&lt;LocalDim,</span> <span class="pre">EmbedDim&gt;</span></code>. Given a free point <span class="math notranslate nohighlight">\(p\)</span>, the algorithm searches for the best approximation of <span class="math notranslate nohighlight">\(p\)</span> in the triangulation. In this sense, it works both for manifold and non-manifold domains (in the last case, the algorithm returns the point on the 2D/3D triangulation border which is nearest to <span class="math notranslate nohighlight">\(p\)</span>).</p>
<p>Computational complexity: let <span class="math notranslate nohighlight">\(N\)</span> be the number of cells and <span class="math notranslate nohighlight">\(n\)</span> the number of points to project.</p>
<ul class="simple">
<li><p>Exact version is <span class="math notranslate nohighlight">\(O(nN)\)</span>.</p></li>
<li><p>Assuming <span class="math notranslate nohighlight">\(n \gg N\)</span> (number of points to project much larger than number of cells), approximate version is <span class="math notranslate nohighlight">\(O(n \log(N))\)</span> (it was <span class="math notranslate nohighlight">\(O(nN)\)</span> in <code class="code docutils literal notranslate"><span class="pre">fdaPDE-1.1-17</span></code>).</p></li>
</ul>
<div class="info admonition">
<p class="admonition-title">Info</p>
<p>The approximate algorithm computes a <code class="code docutils literal notranslate"><span class="pre">KDTree</span></code> for fast locating the nearest mesh node to <span class="math notranslate nohighlight">\(p\)</span> (with computational cost <span class="math notranslate nohighlight">\(O(N \log(N))\)</span>. This cost is negligible if <span class="math notranslate nohighlight">\(n \gg N\)</span>, and performed just once ). Once the nearest point <span class="math notranslate nohighlight">\(q\)</span> is found, a search restricted in the patch of <span class="math notranslate nohighlight">\(q\)</span> is performed, i.e., in the set of cells having <span class="math notranslate nohighlight">\(q\)</span> as vertex (computing the patch costs <span class="math notranslate nohighlight">\(O(\log(N))\)</span>), therefore avoiding a brute force search over the entire mesh (which would cost <span class="math notranslate nohighlight">\(O(N)\)</span>). This is an approximate approach since for highly non-convex region the computed point might be not the nearest to <span class="math notranslate nohighlight">\(p\)</span>.</p>
</div>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>Projection API<a class="headerlink" href="#id7" title="Permalink to this code">Â¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">surface</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">cells</span><span class="p">,</span><span class="w"> </span><span class="n">boundary</span><span class="p">);</span>

<span class="n">DMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">points</span><span class="p">;</span><span class="w"> </span><span class="c1">// free points in 3D space</span>
<span class="c1">// perform projection (use C++ automatic template deduction + tag dispatching)</span>
<span class="n">DMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">proj_points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Projection</span><span class="p">(</span><span class="n">surface</span><span class="p">)(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">fdapde</span><span class="o">::</span><span class="n">Exact</span><span class="p">);</span>
<span class="n">DMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">proj_points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Projection</span><span class="p">(</span><span class="n">surface</span><span class="p">)(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">fdapde</span><span class="o">::</span><span class="n">NotExact</span><span class="p">);</span>

<span class="c1">// NotExact projection requires a O(N log(N)) initialization, this is done just once</span>
<span class="c1">// at first call. You can create a Projection instance and cache</span>
<span class="n">Projection</span><span class="o">&lt;</span><span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">project</span><span class="p">(</span><span class="n">surface</span><span class="p">);</span>
<span class="n">project</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">fdapde</span><span class="o">::</span><span class="n">NotExact</span><span class="p">);</span><span class="w"> </span><span class="c1">// silent initialization here</span>
<span class="n">project</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">fdapde</span><span class="o">::</span><span class="n">NotExact</span><span class="p">);</span><span class="w"> </span><span class="c1">// just perform fast approximate projection</span>

<span class="n">project</span><span class="p">(</span><span class="n">points</span><span class="p">);</span><span class="w"> </span><span class="c1">// defaults to approximate algorithm</span>
</code></pre></div>
</div>
</div>
</li>
</ul>
</li>
<li><p><strong>Minor changes</strong>:</p>
<ul>
<li><p><strong>Optimizers support for objective stopping criterion callback</strong>: if the objective functor provided to the optimizer exposes a method with the following signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><code><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">OptimizerType</span><span class="o">&gt;</span> <span class="nb">bool</span> <span class="n">opt_stopping_criterion</span><span class="p">(</span><span class="n">OptimizerType</span><span class="o">&amp;</span> <span class="n">opt</span><span class="p">);</span>
</code></pre></div>
</div>
<p>any optimizer in the optimization module will execute it to evaluate if convergence has been reached. Users of the optimization module can hence define objective functions with a custom stopping criterion (see, e.g., density estimation in fdaPDE-cpp).</p>
</li>
<li><p><strong>Binary matrix</strong>: binary matrices have proved to be extremely usefull for handling bitmasks and are getting more and more used in the codebase. The following additional methods are now exposed:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">;</span>
<span class="n">BinaryMatrix</span><span class="o">&lt;</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bitmask</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">);</span>

<span class="c1">// writable block expressions</span>
<span class="n">bitmask</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BinaryMatrix</span><span class="o">&lt;</span><span class="n">Dynamic</span><span class="o">&gt;::</span><span class="n">Ones</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="c1">// reshape operation</span>
<span class="n">bitmask</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="c1">// reshape bitmask to a 25 x 100 matrix (no-cost operation)</span>
<span class="n">bitmask</span><span class="p">.</span><span class="n">vector_view</span><span class="p">();</span><span class="w">    </span><span class="c1">// linearize the bitmask into a column vector (no-cost operation)</span>

<span class="c1">// returns all the indexes set to true/false in the bitmask: O(nm) operation</span>
<span class="n">bitmask</span><span class="p">.</span><span class="n">which</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w">  </span><span class="c1">// which true?</span>
<span class="n">bitmask</span><span class="p">.</span><span class="n">which</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"> </span><span class="c1">// which false?</span>
<span class="n">which</span><span class="p">(</span><span class="n">bitmask</span><span class="p">);</span><span class="w">       </span><span class="c1">// implicitly returns true indexes (R style)</span>
</code></pre></div>
</div>
</li>
</ul>
</li>
</ul>
<p><strong>cpp</strong></p>
<ul>
<li><p><strong>Density estimation</strong>: official support for density estimation models. Below the API exposed by the <code class="code docutils literal notranslate"><span class="pre">DensityEstimationBase</span></code> core class for the density module:</p>
<table class="docutils data align-default" id="id8">
<caption><span class="caption-text"><strong>DensityEstimationBase API</strong></span><a class="headerlink" href="#id8" title="Link to this table">Â¶</a></caption>
<colgroup>
<col style="width: 40.0%" />
<col style="width: 60.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">n_obs()</span></code></p></td>
<td><p>number of active data locations. A data location is active if is it not masked.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">n_locs()</span></code></p></td>
<td><p>number of all data locations (e.g., the overall number of observations). It coincides with <code class="code docutils literal notranslate"><span class="pre">n_obs()</span></code> if no observation is masked.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">Psi()</span></code></p></td>
<td><p>the matrix <span class="math notranslate nohighlight">\(\Psi\)</span> (evaluation of spatial basis functions at data location) for space-only problems, the matrix <span class="math notranslate nohighlight">\(\Upsilon\)</span> for space-time problems (as defined in <em>Begu, B., Panzeri, S. (2022), Space-Time Density Estimation with Partial Differential Equation Regularization. PACS project. Pag 9.</em>)</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">Upsilon()</span></code></p></td>
<td><p>if some observation is masked, returns the matrix provided by <code class="code docutils literal notranslate"><span class="pre">Psi()</span></code> where rows corresponding to masked observations are set to zero, otherwise is equivalent to calling <code class="code docutils literal notranslate"><span class="pre">Psi()</span></code>. Upper models should mainly interact with this method, instead of directly calling <code class="code docutils literal notranslate"><span class="pre">Psi()</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">PsiQuad()</span></code></p></td>
<td><p>the matrix of evaluations of the reference basis system at the quadrature nodes. Already tensorized for space-time problems.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">w()</span></code></p></td>
<td><p>weights of the quadrature rule used for the approximation of <span class="math notranslate nohighlight">\(\int_{\Omega} e^g\)</span>. Already tensorized for space-time problems.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">int_exp(const</span> <span class="pre">DVector&lt;double&gt;&amp;</span> <span class="pre">g)</span></code></p></td>
<td><p>evaluation of <span class="math notranslate nohighlight">\(\int_{\Omega} e^g\)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">int_exp()</span></code></p></td>
<td><p>evaluation of <span class="math notranslate nohighlight">\(\int_{\Omega} e^{\hat g}\)</span>, where <span class="math notranslate nohighlight">\(\hat g\)</span> is the current estimation of the log density field.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">grad_int_exp(const</span> <span class="pre">DVector&lt;double&gt;&amp;</span> <span class="pre">g)</span></code></p></td>
<td><p>evaluation of the gradient of <span class="math notranslate nohighlight">\(\int_{\Omega} e^g\)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">grad_int_exp()</span></code></p></td>
<td><p>evaluation of the gradient of <span class="math notranslate nohighlight">\(\int_{\Omega} e^{\hat g}\)</span>, where <span class="math notranslate nohighlight">\(\hat g\)</span> is the current estimation of the log density field.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">g()</span></code></p></td>
<td><p>expansion coefficient vector of the log density field.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">f()</span></code></p></td>
<td><p>expansion coefficient vector of the density field, e.g. <span class="math notranslate nohighlight">\(f = e^g\)</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">masked_obs()</span></code></p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">BinaryVector&lt;Dynamic&gt;</span></code> of masked observations.</p></td>
</tr>
</tbody>
</table>
<p>As always, in addition, a model inheriting from <code class="code docutils literal notranslate"><span class="pre">DensityEstimationBase</span></code> has access to the specific API induced by the choosen regularization. Check the source code for details.</p>
<div class="info admonition">
<p class="admonition-title">The masking mechanism</p>
<p>This is something already shown in February 2024. At the statistical level, âmaskingâ means to remove some observations (the masked ones) from the fitting. This corresponds to set to zero all the rows of the matrix <span class="math notranslate nohighlight">\(\Psi\)</span> (or <span class="math notranslate nohighlight">\(\Upsilon\)</span>) corresponding to masked observations. This mechanism is used, for instance, by the <code class="code docutils literal notranslate"><span class="pre">KCV</span></code> class to perform CV selection of the smoothing parameters.</p>
<p>By doing so, all models inheriting from <code class="code docutils literal notranslate"><span class="pre">DensityEstimationBase</span></code> have immediate support for smoothing parameter selection by K-fold Cross Validation.</p>
</div>
<p>Class <code class="code docutils literal notranslate"><span class="pre">DEPDE</span></code> implements the density estimation model shown in <em>Ferraccioli, F., Arnone, E., Finos, L., Ramsay, J.O., Sangalli, L.M. (2021), Nonparametric density estimation over complicated domains, Journal of the Royal Statistical Society</em> (space-only) and <em>Begu, B., Panzeri, S., Arnone, E., Carey, M., and Sangalli, L.M. (2024), A nonparametric penalized likelihood approach to density estimation of space-time point patterns, Spatial Statistics</em> (space-time).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RegularizationType_</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DEPDE</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">DensityEstimationBase</span><span class="o">&lt;</span><span class="n">DEPDE</span><span class="o">&lt;</span><span class="n">RegularizationType_</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">RegularizationType_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>
</code></pre></div>
</div>
<p>Because the resolution strategy for a density estimation model is a penalized log-likelihood minimization, <code class="xref py py-class docutils literal notranslate"><span class="pre">DEPDE</span></code> exposes an interface compatible with the optimization module, i.e. it acts exactly as an optimizer objective function (see the optimization module API for details).</p>
<table class="docutils data align-default" id="id9">
<caption><span class="caption-text"><strong>DEPDE API</strong></span><a class="headerlink" href="#id9" title="Link to this table">Â¶</a></caption>
<colgroup>
<col style="width: 40.0%" />
<col style="width: 60.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">operator(const</span> <span class="pre">DVector&lt;double&gt;&amp;</span> <span class="pre">g)</span></code></p></td>
<td><p>evaluates the penalized log-likelihood functional at <span class="math notranslate nohighlight">\(g\)</span>, i.e. computes <span class="math notranslate nohighlight">\(L(g) = - 1^\top \Upsilon g + \int_{\Omega} e^g + g^\top P_{\lambda} g\)</span></p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">derive()</span></code></p></td>
<td><p>returns a <code class="code docutils literal notranslate"><span class="pre">std::function&lt;DVector(const</span> <span class="pre">DVector&lt;double&gt;&amp;)&gt;</span></code> encoding the gradient of the penalized log-likelihood functional.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">bool</span> <span class="pre">opt_stopping_criterion(OptimizerType&amp;)</span></code></p></td>
<td><p>stops the optimization algorithm if the relative difference between the log-likelihood or the penalized log-likelihood is below a user defined tolerance (defaults to <span class="math notranslate nohighlight">\(10^{-5}\)</span>).</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">set_tolerance(double)</span></code></p></td>
<td><p>sets the tolerance for the custom stopping criterion (the one triggered by <code class="code docutils literal notranslate"><span class="pre">opt_stopping_criterion()</span></code>).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">set_g_init(const</span> <span class="pre">DMatrix&lt;double&gt;&amp;)</span></code></p></td>
<td><p>sets the initial log-density expansion coefficient vector.</p>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">DEPDE</span></code> does not compute any initialization density (e.g., by heat-process). Instead, it requests the initialization point, which must be externally computed.</p>
</div>
</td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">set_optimizer(OptimizerType&amp;&amp;)</span></code></p></td>
<td><p>sets the optimization algorithm for the minimization of the penalized log-likelihood functional <span class="math notranslate nohighlight">\(L(g)\)</span>. The optimizer is internally type-erased.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">init()</span></code></p></td>
<td><p>initializes the model stack.</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">solve()</span></code></p></td>
<td><p>triggers the optimizer for the minimization of the penalized log-likelihood.</p></td>
</tr>
</tbody>
</table>
<p>Check the code snippet below for the provided API:</p>
<div class="example admonition">
<p class="admonition-title">Example</p>
<div class="literal-block-wrapper docutils container" id="id10">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>DEPDE API<a class="headerlink" href="#id10" title="Permalink to this code">Â¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="c1">// assume mesh and laplacian penalty already defined...</span>

<span class="c1">// space-only model</span>
<span class="n">DEPDE</span><span class="o">&lt;</span><span class="n">SpaceOnly</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">penalty</span><span class="p">);</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_lambda_D</span><span class="p">(</span><span class="mf">0.1</span><span class="p">);</span>

<span class="c1">// data in point-pattern processes coincide with locations</span>
<span class="n">BlockFrame</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">df</span><span class="p">;</span>
<span class="n">df</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SPACE_LOCS</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>

<span class="n">model</span><span class="p">.</span><span class="n">set_tolerance</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">);</span><span class="w"> </span><span class="c1">// set tolerance on custom stopping criterion</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">df</span><span class="p">);</span>

<span class="c1">// set optimization algorithm (here you have access to the whole optimization API)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">max_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span>
<span class="kt">double</span><span class="w"> </span><span class="n">opt_tolerance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e-5</span><span class="p">;</span><span class="w"> </span><span class="c1">// set optimizer tolerance (looks for the norm of the objective gradient)</span>
<span class="kt">double</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e-2</span><span class="p">;</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_optimizer</span><span class="p">(</span><span class="n">BFGS</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">max_iter</span><span class="p">,</span><span class="w"> </span><span class="n">opt_tolerance</span><span class="p">,</span><span class="w"> </span><span class="n">step</span><span class="p">});</span><span class="w"> </span><span class="c1">// optimizer must be Dynamic</span>

<span class="c1">// gradient descent with adaptive step</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_optimizer</span><span class="p">(</span><span class="n">GradientDescent</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="n">BacktrackingLineSearch</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">max_iter</span><span class="p">,</span><span class="w"> </span><span class="n">opt_tolerance</span><span class="p">,</span><span class="w"> </span><span class="n">step</span><span class="p">});</span>
<span class="c1">// in general, you can set any optimization algorithm in the optimization module</span>

<span class="c1">// initialize and solve</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_g_init</span><span class="p">(...);</span><span class="w"> </span><span class="c1">// optimization algorithm init point</span>
<span class="n">model</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
<span class="n">model</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>

<span class="n">model</span><span class="p">.</span><span class="n">g</span><span class="p">();</span><span class="w"> </span><span class="c1">// estimated log-density field</span>

<span class="c1">// you can also approach the fitting as a pure optimization problem (emphasis on the optimizer)</span>

<span class="n">BFGS</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="n">WolfeLineSearch</span><span class="o">&gt;</span><span class="w"> </span><span class="n">optimizer</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,</span><span class="w"> </span><span class="n">opt_tolerance</span><span class="p">,</span><span class="w"> </span><span class="n">step</span><span class="p">);</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">g_init</span><span class="p">);</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">optimum</span><span class="p">();</span><span class="w"> </span><span class="c1">// estimated log-density field</span>

<span class="c1">// and by just changing the RegularizetionType template, you get space-time :)</span>
<span class="n">DEPDE</span><span class="o">&lt;</span><span class="n">SpaceTimeSeparable</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">penalty_space</span><span class="p">,</span><span class="w"> </span><span class="n">penalty_time</span><span class="p">);</span>
<span class="c1">// all the API above stays valid</span>
</code></pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption highlight"><span class="filename"><span class="caption-text">
</span>DEPDE KFold-CV API<a class="headerlink" href="#id11" title="Permalink to this code">Â¶</a></span></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="c1">// assume mesh and laplacian penalty already defined...</span>

<span class="n">DEPDE</span><span class="o">&lt;</span><span class="n">SpaceOnly</span><span class="o">&gt;</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">penalty</span><span class="p">);</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">df</span><span class="p">);</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_optimizer</span><span class="p">(</span><span class="n">BFGS</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="n">WolfeLineSearch</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">max_iter</span><span class="p">,</span><span class="w"> </span><span class="n">opt_tolerance</span><span class="p">,</span><span class="w"> </span><span class="n">step</span><span class="p">});</span>

<span class="kt">int</span><span class="w"> </span><span class="n">n_folds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdapde</span><span class="o">::</span><span class="n">random_seed</span><span class="p">;</span>
<span class="n">KCV</span><span class="w"> </span><span class="nf">kcv</span><span class="p">(</span><span class="n">n_folds</span><span class="p">,</span><span class="w"> </span><span class="n">seed</span><span class="p">);</span>

<span class="n">DMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lambda_grid</span><span class="p">;</span><span class="w"> </span><span class="c1">// the grid of smoothing parameters to explore</span>
<span class="n">DMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">g_init_grid</span><span class="p">;</span><span class="w"> </span><span class="c1">// for each value of lambda, the initial density field (computed in some way)</span>
<span class="n">model</span><span class="p">.</span><span class="n">set_g_init</span><span class="p">(</span><span class="n">g_init_grid</span><span class="p">);</span>

<span class="c1">// calibrate the model</span>
<span class="n">kcv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">lambda_grid</span><span class="p">);</span><span class="w"> </span><span class="c1">// uses DEPDE::CVScore scoring function, see below for details</span>

<span class="c1">// at the end you get</span>
<span class="n">kcv</span><span class="p">.</span><span class="n">avg_scores</span><span class="p">();</span>
<span class="n">kcv</span><span class="p">.</span><span class="n">std_scores</span><span class="p">();</span>
<span class="n">kcv</span><span class="p">.</span><span class="n">optimum</span><span class="p">();</span><span class="w"> </span><span class="c1">// optimal smoothing parameter</span>
</code></pre></div>
</div>
</div>
<div class="info admonition">
<p class="admonition-title">Info</p>
<p><code class="code docutils literal notranslate"><span class="pre">DEPDE</span></code> internally defines its cross-validation scoring index as a functor of type <code class="code docutils literal notranslate"><span class="pre">DEPDE::CVScore</span></code>, exposing a call operator compatible with the <code class="code docutils literal notranslate"><span class="pre">KCV</span></code> requirement. <code class="code docutils literal notranslate"><span class="pre">DEPDE::CVScore</span></code> implements Equation (1.18) of <em>Begu, B., Panzeri, S. (2022), Space-Time Density Estimation with Partial Differential Equation Regularization. PACS project. Pag 17.</em></p>
</div>
<div class="tip admonition">
<p class="admonition-title">Tip</p>
<p>When a model of type <code class="code docutils literal notranslate"><span class="pre">ModelType</span></code> exposes a public type <code class="code docutils literal notranslate"><span class="pre">ModelType::CVScore</span></code>, calling <code class="code docutils literal notranslate"><span class="pre">KCV::fit(model,</span> <span class="pre">lambda_grid)</span></code> fallbacks to the use of <code class="code docutils literal notranslate"><span class="pre">ModelType::CVScore</span></code> as cross validation index (rises a static assert otherwise). Specifically, <code class="code docutils literal notranslate"><span class="pre">ModelType::CVScore</span></code> must expose a constructor with the following signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="n">CVScore</span><span class="p">(</span><span class="n">ModelType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
</code></pre></div>
</div>
<p>and expose a call operator</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="kt">double</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">fold</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lambda</span><span class="p">,</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryVector</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">train_mask</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryVector</span><span class="o">&lt;</span><span class="n">fdapde</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">test_mask</span><span class="p">);</span>
</code></pre></div>
</div>
</div>
</div>
</li>
</ul>
<p><strong>R (base)</strong></p>
<p>Be prepared, almost ready (at least on paper).</p>







  
  




  



                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2024, fdaPDE.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    8.2.3.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.expand", "navigation.sections"], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
      
        <script src="../_static/sphinx_immaterial_theme.32136f45f91ae6956.min.js?v=a7a9472a"></script>
        <script id="MathJax-script" src="../_static/mathjax/tex-mml-chtml.js?v=cadf963e"></script>
    
  </body>
</html>