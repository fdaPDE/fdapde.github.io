


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../index.html">
      
      
        <link rel="next" href="tut_2.html">
      
      
      <link rel="icon" href="">
    
    
      
        <title>Example 1: A non-linear diffusion reaction problem - fdaPDE  documentation</title>
      
    
    
      
      


    
    
      
    
    
      
        
        
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="../_static/sphinx_immaterial_theme.243c798c14787bf0e.min.css?v=a4497153" />
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#implementation" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../index.html" title="fdaPDE  documentation" class="md-header__button md-logo" aria-label="fdaPDE  documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            fdaPDE  documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Example 1: A non-linear diffusion reaction problem
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
                
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="fdaPDE  documentation" class="md-nav__button md-logo" aria-label="fdaPDE  documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>
    </a>
    fdaPDE  documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Example 1:<wbr> A non-<wbr>linear diffusion reaction problem
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="#" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Example 1:<wbr> A non-<wbr>linear diffusion reaction problem
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#implementation" class="md-nav__link">
    
    <span class="md-ellipsis">
      Implementation
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="tut_2.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Example 2:<wbr> The Heat equation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="tut_5.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Example 3:<wbr> SUPG for advection dominated equations
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="tut_4.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Example 4:<wbr> The Stokes problem
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="alpha_testing.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Alpha testing fda<wbr>PDE 2.<wbr>0 <wbr>[cpp]
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
                
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" hidden>
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#implementation" class="md-nav__link">
    
    <span class="md-ellipsis">
      Implementation
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset" role="main">
                
                
                  
  



<h1 id="example-1-a-non-linear-diffusion-reaction-problem">Example 1: A non-linear diffusion reaction problem<a class="headerlink" href="#example-1-a-non-linear-diffusion-reaction-problem" title="Link to this heading">¶</a></h1>
<p>In this example we solve a non-linear diffusion reaction problem, corresponding to the stationary case of the Fisher KPP equation. Specifically, the problem is described by the following equation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
- \eta \Delta u + \alpha u (1-u) = f &amp; \qquad \text{in } \Omega \\
  u = g &amp; \qquad \text{on } \partial \Omega
\end{align}\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(\Omega = [0,1]^2\)</span>. Being the problem non-linear, to find a solution (which esists unique for <span class="math notranslate nohighlight">\(\Omega\)</span> Lipschitz and <span class="math notranslate nohighlight">\(\eta &gt; 0, \alpha &gt; 0\)</span>) we need some iterative scheme which converges, with some reasonable degree of accuracy, to the solution. We here develop a Newton scheme following the work done in <span id="id1">[<a class="reference internal" href="#id3" title="Carlotta Gatti and Emanuele Tamburini. Solving nonlinear elliptic equations with femr. Advanced Programming for Scientific Computing project, 2023.">GT23</a>]</span>. Let <span class="math notranslate nohighlight">\(\mathcal{L}(u) = -\eta \Delta u + \alpha u(1-u) - f\)</span>, the Netwon scheme reads as follow:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
  D \mathcal{L}_{u^k}(h) = -\mathcal{L}(u^k) \\
  u^{k+1} = u^k + h
\end{align}\end{split}\]</div>
<p>being <span class="math notranslate nohighlight">\(D \mathcal{L}_{u^k}(h)\)</span> the Gateaux derivative of the operator <span class="math notranslate nohighlight">\(\mathcal{L}\)</span> in the direction <span class="math notranslate nohighlight">\(h\)</span>. Computations leads to the following expression for the Gateaux derivative (it is not the point of the following example how to compute such functional derivative):</p>
<div class="math notranslate nohighlight">
\[D \mathcal{L}_{u^k}(h) = - \eta \Delta h + \alpha (1 - 2 u^k) h\]</div>
<p>Substituting the above expression in the Newton formula we obtain the following linearized problem to be solved for <span class="math notranslate nohighlight">\(h\)</span></p>
<div class="math notranslate nohighlight">
\[- \eta \Delta h + \alpha (1 - 2 u^k) h = f - (-\eta \Delta u^k + \alpha u^k(1-u^k)).\]</div>
<p>Finally, observing that by definition of Newton update, <span class="math notranslate nohighlight">\(h = u^{k+1} - u^k\)</span>, we get the more computationally efficient iteration</p>
<div class="math notranslate nohighlight">
\[- \eta \Delta u^{k+1} + \alpha (1 - 2 u^k) u^{k+1} = f - \alpha (u^k)^2\]</div>
<p>As always, fdaPDE requires the weak formulation of the differential problem above. Following the Galerkin approach, let <span class="math notranslate nohighlight">\(V_h\)</span> a proper finite dimensional subspace of the space where we seek the solution, and let <span class="math notranslate nohighlight">\(u^{k+1}, u^k, v \in V_h\)</span>. Multiplying both sides of the last equation by the test function <span class="math notranslate nohighlight">\(v\)</span> and integrating we recover the following variational identity</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega} \nabla u^{k+1} \cdot \nabla v + \alpha (1-u^k) u^{k+1} v - \int_{\Omega} \alpha u^k u^{k+1} v = \int_{\Omega} f - \alpha (u^k)^2 v \quad \forall v \in V_h\]</div>
<p>which we iteratively solve for <span class="math notranslate nohighlight">\(u^{k+1}\)</span> until convergence.</p>
<h2 id="implementation">Implementation<a class="headerlink" href="#implementation" title="Link to this heading">¶</a></h2>
<p>The first step in any finite element code is the definition of the problem geometry. As we are going to iterate several times over the mesh is convinient to compute the cells once and cache them to obtain a fast re-access to the mesh. This option is enabled by activating the cell caching.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">unit_square</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;::</span><span class="n">UnitSquare</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span><span class="w"> </span><span class="n">cache_cells</span><span class="p">);</span>
</code></pre></div>
</div>
<p>Once we have a discretization of the domain <span class="math notranslate nohighlight">\(\Omega\)</span>, we can instatiate a (linear) finite element space on it togheter with trial and test functions.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="n">FeSpace</span><span class="w"> </span><span class="nf">Vh</span><span class="p">(</span><span class="n">unit_square</span><span class="p">,</span><span class="w"> </span><span class="n">P1</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">);</span><span class="w"> </span><span class="c1">// piecewise linear continuous scalar finite elements</span>
<span class="n">TrialFunction</span><span class="w"> </span><span class="nf">u</span><span class="p">(</span><span class="n">Vh</span><span class="p">);</span>
<span class="n">TestFunction</span><span class="w">  </span><span class="nf">v</span><span class="p">(</span><span class="n">Vh</span><span class="p">);</span>
</code></pre></div>
</div>
<p>Because we are dealing with a non-linear problem, we need an object describing the current and previous solution <span class="math notranslate nohighlight">\(u^{k+1}\)</span> and <span class="math notranslate nohighlight">\(u^k\)</span>. This is achieved using the <code class="code docutils literal notranslate"><span class="pre">FeFunction</span></code> type, which represents a scalar field <span class="math notranslate nohighlight">\(u\)</span> written with respect to a finite element basis system, e.g. it represents <span class="math notranslate nohighlight">\(u(\boldsymbol{p})\)</span> as <span class="math notranslate nohighlight">\(\sum_{i=1}^N c_i \psi_i(\boldsymbol{p})\)</span> given the expansion coefficient vector <span class="math notranslate nohighlight">\(\boldsymbol{c} = [c_1, \ldots, c_N]\)</span>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="n">FeFunction</span><span class="w"> </span><span class="nf">u_prev</span><span class="p">(</span><span class="n">Vh</span><span class="p">),</span><span class="w"> </span><span class="n">solution</span><span class="p">(</span><span class="n">Vh</span><span class="p">);</span>
</code></pre></div>
</div>
<p>We now have all the ingredients to assemble our bilinear forms. First we notice that we can save some computational time observing that</p>
<div class="math notranslate nohighlight">
\[- \int_{\Omega} \alpha (u^k)^2 v = \sum_{i=1}^N \sum_{j=1}^N \Biggl[ \int_{\Omega} -\alpha u^k \psi_i \psi_j \Biggr] c_i = A_2 \boldsymbol{c}\]</div>
<p>being <span class="math notranslate nohighlight">\(A_2\)</span> the discretization matrix of the bilinear form <span class="math notranslate nohighlight">\(b(u, v) = - \int_{\Omega} \alpha u^k u v\)</span>, which can therefore be computed once for the lhs and rhs. For this reason, we defined two bilinear forms as follow (look how the writing is almost equivalent to the mathematical one):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">integral</span><span class="p">(</span><span class="n">unit_square</span><span class="p">)(</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="w"> </span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">u_prev</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">integral</span><span class="p">(</span><span class="n">unit_square</span><span class="p">)(</span><span class="o">-</span><span class="n">u_prev</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
</code></pre></div>
</div>
<p>We then define the forcing term as a plain <code class="code docutils literal notranslate"><span class="pre">ScalarField</span></code> togheter with the forcing functional <span class="math notranslate nohighlight">\(F(v) = \int_{\Omega} f v\)</span>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="n">ScalarField</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">decltype</span><span class="p">([](</span><span class="k">const</span><span class="w"> </span><span class="n">PointT</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-9</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">12</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="p">})</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">integral</span><span class="p">(</span><span class="n">unit_square</span><span class="p">,</span><span class="w"> </span><span class="n">QS2DP4</span><span class="p">)(</span><span class="n">f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
</code></pre></div>
</div>
<p>Observe that we explicitly require an higher order quadrature specifying the quadrature formula <code class="code docutils literal notranslate"><span class="pre">QS2DP4</span></code> for the exact integration of order 4 polynomials as second argument of the <code class="code docutils literal notranslate"><span class="pre">integral</span></code> function. Finally, we define non-homegeneous Dirichlet boundary conditions <span class="math notranslate nohighlight">\(g(\boldsymbol{x}) = 3x^2 + 2y^2\)</span> on all the boundary of the domain</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="n">ScalarField</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">decltype</span><span class="p">([](</span><span class="k">const</span><span class="w"> </span><span class="n">PointT</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="p">})</span><span class="o">&gt;</span><span class="w"> </span><span class="n">g</span><span class="p">;</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dof_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vh</span><span class="p">.</span><span class="n">dof_handler</span><span class="p">();</span>
<span class="n">dof_handler</span><span class="p">.</span><span class="n">set_dirichlet_constraint</span><span class="p">(</span><span class="cm">/* on = */</span><span class="w"> </span><span class="n">BoundaryAll</span><span class="p">,</span><span class="w"> </span><span class="cm">/* data = */</span><span class="w"> </span><span class="n">g</span><span class="p">);</span>
</code></pre></div>
</div>
<p>Recall that Dirichlet boundary conditions are implemented as constraints on the degrees of freedom of the linear system <span class="math notranslate nohighlight">\(A \boldsymbol{c} = \boldsymbol{b}\)</span> deriving form the discretization of the variational problem, and that we must later enforce them on the pair <span class="math notranslate nohighlight">\((A, \boldsymbol{b})\)</span> before solving the linear system, using the <code class="code docutils literal notranslate"><span class="pre">enforce_constraints</span></code> method.</p>
<p>We can now find an initial point for the Newton scheme. To this end, we solve the linerized problem with initial guess <span class="math notranslate nohighlight">\(u = 0\)</span>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="n">u_prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">Zero</span><span class="p">(</span><span class="n">Vh</span><span class="p">.</span><span class="n">n_dofs</span><span class="p">());</span><span class="w">   </span><span class="c1">// initial guess u = 0</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">assemble</span><span class="p">();</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F</span><span class="p">.</span><span class="n">assemble</span><span class="p">();</span>
<span class="n">dof_handler</span><span class="p">.</span><span class="n">enforce_constraints</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">v_</span><span class="p">);</span>
<span class="c1">// linear system solve A*u_prev = v_ using Cholesky factorization</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">SimplicialLLT</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">lin_solver</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">u_prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lin_solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">v_</span><span class="p">);</span>
</code></pre></div>
</div>
<p>The code fragment above effectivelly assemble the discretization matrix <code class="code docutils literal notranslate"><span class="pre">A</span></code> for the bilinear form <span class="math notranslate nohighlight">\(\int_{\Omega} \nabla u^0 \cdot \nabla v + u^0 v\)</span> togheter with the discretizing vector <code class="code docutils literal notranslate"><span class="pre">v_</span></code> of the forcing functional <span class="math notranslate nohighlight">\(F\)</span>. Then, it sets the Dirichlet conditions at the boundary via the <code class="code docutils literal notranslate"><span class="pre">enforce_constaints</span></code> method of the <code class="code docutils literal notranslate"><span class="pre">dof_handler</span></code> object. Finally, observing that the bilinear form is SPD, solves the FEM linear system using a Cholesky factorization and sets <span class="math notranslate nohighlight">\(u^0\)</span> to the solution of this linear system.</p>
<p>We can finally start looping until convergence, iteratively solving the recurrence</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega} \nabla u^{k+1} \cdot \nabla v + \alpha (1-u^k) u^{k+1} v - \int_{\Omega} \alpha u^k u^{k+1} v = \int_{\Omega} f - \alpha (u^k)^2 v \quad \forall v \in V_h\]</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><code><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1e-7</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">assemble</span><span class="p">();</span>
<span class="w">   </span><span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">assemble</span><span class="p">();</span>
<span class="w">   </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_prev</span><span class="p">.</span><span class="n">coeff</span><span class="p">();</span>
<span class="w">   </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A2</span><span class="p">;</span>
<span class="w">   </span><span class="n">dof_handler</span><span class="p">.</span><span class="n">enforce_constraints</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="w">   </span><span class="n">lin_solver</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="w">   </span><span class="n">solution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lin_solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

<span class="w">   </span><span class="c1">// update error</span>
<span class="w">   </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u_prev</span><span class="p">.</span><span class="n">coeff</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">solution</span><span class="p">.</span><span class="n">coeff</span><span class="p">()).</span><span class="n">norm</span><span class="p">();</span>
<span class="w">   </span><span class="n">u_prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solution</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>The code just assembles <code class="code docutils literal notranslate"><span class="pre">A1</span></code> and <code class="code docutils literal notranslate"><span class="pre">A2</span></code>, updates the right hand side <span class="math notranslate nohighlight">\(\int_{\Omega} f - \alpha (u^k)^2 v\)</span>, enforces the Dirichlet constaints on the resulting linear system and solves the resulting linear system.</p>
<div class="abstract admonition">
<p class="admonition-title">The complete script</p>
<div class="highlight-cpp notranslate"><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fdaPDE/finite_elements.h&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">fdapde</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// useful typedef and constants definition</span>
<span class="w">   </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">local_dim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">   </span><span class="k">using</span><span class="w"> </span><span class="n">PointT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">local_dim</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">   </span><span class="n">Triangulation</span><span class="o">&lt;</span><span class="n">local_dim</span><span class="p">,</span><span class="w"> </span><span class="n">local_dim</span><span class="o">&gt;</span><span class="w"> </span><span class="n">unit_square</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;::</span><span class="n">UnitSquare</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span><span class="w"> </span><span class="n">cache_cells</span><span class="p">);</span>

<span class="w">   </span><span class="n">FeSpace</span><span class="w"> </span><span class="n">Vh</span><span class="p">(</span><span class="n">unit_square</span><span class="p">,</span><span class="w"> </span><span class="n">P1</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">);</span>
<span class="w">   </span><span class="c1">// create trial and test functions</span>
<span class="w">   </span><span class="n">TrialFunction</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">Vh</span><span class="p">);</span>
<span class="w">   </span><span class="n">TestFunction</span><span class="w">  </span><span class="n">v</span><span class="p">(</span><span class="n">Vh</span><span class="p">);</span>
<span class="w">   </span><span class="c1">// current solution and solution at previous step</span>
<span class="w">   </span><span class="n">FeFunction</span><span class="w"> </span><span class="n">u_prev</span><span class="p">(</span><span class="n">Vh</span><span class="p">),</span><span class="w"> </span><span class="n">solution</span><span class="p">(</span><span class="n">Vh</span><span class="p">);</span>

<span class="w">   </span><span class="c1">// define bilinear forms</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">integral</span><span class="p">(</span><span class="n">unit_square</span><span class="p">)(</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="w"> </span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">u_prev</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">integral</span><span class="p">(</span><span class="n">unit_square</span><span class="p">)(</span><span class="o">-</span><span class="n">u_prev</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>

<span class="w">   </span><span class="c1">// define forcing functional</span>
<span class="w">   </span><span class="n">ScalarField</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">decltype</span><span class="p">([](</span><span class="k">const</span><span class="w"> </span><span class="n">PointT</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="mi">-9</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">12</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">   </span><span class="p">})</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">integral</span><span class="p">(</span><span class="n">unit_square</span><span class="p">,</span><span class="w"> </span><span class="n">QS2DP4</span><span class="p">)(</span><span class="n">f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>

<span class="w">   </span><span class="c1">// define dirichlet data</span>
<span class="w">   </span><span class="n">ScalarField</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">decltype</span><span class="p">([](</span><span class="k">const</span><span class="w"> </span><span class="n">PointT</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="p">})</span><span class="o">&gt;</span><span class="w"> </span><span class="n">g</span><span class="p">;</span>
<span class="w">   </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dof_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vh</span><span class="p">.</span><span class="n">dof_handler</span><span class="p">();</span>
<span class="w">   </span><span class="n">dof_handler</span><span class="p">.</span><span class="n">set_dirichlet_constraint</span><span class="p">(</span><span class="cm">/* on = */</span><span class="w"> </span><span class="n">BoundaryAll</span><span class="p">,</span><span class="w"> </span><span class="cm">/* data = */</span><span class="w"> </span><span class="n">g</span><span class="p">);</span>

<span class="w">   </span><span class="c1">// Newton scheme initialization (solve linearized problem with initial guess u = 0)</span>
<span class="w">   </span><span class="n">u_prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">Zero</span><span class="p">(</span><span class="n">Vh</span><span class="p">.</span><span class="n">n_dofs</span><span class="p">());</span><span class="w">   </span><span class="c1">// initial guess u = 0</span>
<span class="w">   </span><span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">assemble</span><span class="p">();</span><span class="w">   </span><span class="c1">// this actually assembles dot(grad(u), grad(v)) + u * v</span>
<span class="w">   </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F</span><span class="p">.</span><span class="n">assemble</span><span class="p">();</span>
<span class="w">   </span><span class="n">dof_handler</span><span class="p">.</span><span class="n">enforce_constraints</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">v_</span><span class="p">);</span>
<span class="w">   </span><span class="c1">// linear system solve A*u_prev = v_ using Cholesky factorization</span>
<span class="w">   </span><span class="n">Eigen</span><span class="o">::</span><span class="n">SimplicialLLT</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">lin_solver</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="w">   </span><span class="n">u_prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lin_solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">v_</span><span class="p">);</span>

<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1e-7</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">assemble</span><span class="p">();</span>
<span class="w">       </span><span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">assemble</span><span class="p">();</span>
<span class="w">       </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_prev</span><span class="p">.</span><span class="n">coeff</span><span class="p">();</span><span class="w">    </span><span class="c1">// update rhs</span>
<span class="w">       </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A2</span><span class="p">;</span>
<span class="w">       </span><span class="n">dof_handler</span><span class="p">.</span><span class="n">enforce_constraints</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="w">       </span><span class="n">lin_solver</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="w">       </span><span class="n">solution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lin_solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

<span class="w">       </span><span class="c1">// update error</span>
<span class="w">       </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u_prev</span><span class="p">.</span><span class="n">coeff</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">solution</span><span class="p">.</span><span class="n">coeff</span><span class="p">()).</span><span class="n">norm</span><span class="p">();</span>
<span class="w">       </span><span class="n">u_prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solution</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
</div>
</div>
<a class="reference internal image-reference" href="../_images/fisherkpp.png"><img alt="../_images/fisherkpp.png" class="align-center" src="../_images/fisherkpp.png" style="width: 400px;" />
</a>
<div class="docutils container" id="id2">
<div role="list" class="citation-list">
<div class="citation" id="id3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">GT23</a><span class="fn-bracket">]</span></span>
<p>Carlotta Gatti and Emanuele Tamburini. Solving nonlinear elliptic equations with femr. <em>Advanced Programming for Scientific Computing project</em>, 2023.</p>
</div>
</div>
</div>







  
  




  



                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2024, fdaPDE.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    8.2.3.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.expand", "navigation.sections"], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
      
        <script src="../_static/sphinx_immaterial_theme.32136f45f91ae6956.min.js?v=a7a9472a"></script>
        <script id="MathJax-script" src="../_static/mathjax/tex-mml-chtml.js?v=cadf963e"></script>
    
  </body>
</html>